<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WW2 Fighter Plane Simulator</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Rajdhani', 'Verdana', sans-serif;
            background-color: #000;
            color: #0df;
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            outline: none;
        }
        /* Cockpit UI Framework */
        .cockpit-panel {
            position: fixed;
            background-color: rgba(0, 15, 30, 0.7);
            color: #0df;
            border: 1px solid #0df;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 223, 255, 0.5), inset 0 0 5px rgba(0, 223, 255, 0.2);
            padding: 12px;
            backdrop-filter: blur(3px);
            z-index: 100;
        }
        .cockpit-panel h3 {
            margin: 0 0 10px 0;
            text-transform: uppercase;
            font-size: 14px;
            letter-spacing: 1px;
            text-align: center;
            border-bottom: 1px solid #0af;
            padding-bottom: 5px;
            color: #fff;
            text-shadow: 0 0 5px #0df;
        }
        .cockpit-panel p {
            margin: 5px 0;
            font-size: 13px;
        }
        
        /* Primary Flight Information */
        #ui {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            pointer-events: none;
            text-align: center;
        }
        #ui div {
            font-size: 18px;
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-weight: bold;
        }
        #ui div:before, #ui div:after {
            content: "—";
            color: #0af;
        }
        
        /* Side Panels Layout */
        #controls {
            left: 20px;
            bottom: 20px;
            width: 150px;
        }
        
        #environment-selector {
            right: 20px;
            top: 20px;
            width: 150px;
        }
        
        #time-control {
            right: 20px;
            bottom: 20px;
            width: 150px;
        }
        
        /* Button and Input Styling */
        button {
            background-color: rgba(0, 40, 80, 0.8);
            color: #0df;
            border: 1px solid #0df;
            border-radius: 5px;
            padding: 4px 8px;
            margin: 5px 0;
            cursor: pointer;
            transition: all 0.2s ease;
            width: 100%;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 1px;
        }
        button:hover {
            background-color: rgba(0, 150, 200, 0.3);
            box-shadow: 0 0 10px rgba(0, 223, 255, 0.7);
        }
        button:active {
            background-color: rgba(0, 180, 230, 0.5);
        }
        
        select {
            width: 100%;
            padding: 5px;
            margin: 5px 0;
            background-color: rgba(0, 20, 40, 0.8);
            color: #0df;
            border: 1px solid #0af;
            border-radius: 5px;
            cursor: pointer;
            outline: none;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            height: 5px;
            background: linear-gradient(to right, #023 0%, #0df 50%, #023 100%);
            border-radius: 5px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #0df;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 223, 255, 0.7);
        }
        
        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #001525;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #0df;
            font-size: 24px;
            z-index: 1000;
        }
        .progress {
            width: 60%;
            background-color: rgba(0, 20, 40, 0.5);
            border-radius: 10px;
            margin-top: 30px;
            overflow: hidden;
            border: 1px solid #0af;
        }
        .progress-bar {
            width: 0%;
            height: 20px;
            background: linear-gradient(to right, #0af, #0df);
            border-radius: 8px;
            transition: width 0.3s;
        }
        
        /* Crosshair */
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            pointer-events: none;
            opacity: 0.7;
        }
        #crosshair .lines {
            position: absolute;
            background-color: rgba(0, 223, 255, 0.7);
        }
        #crosshair .horizontal {
            width: 40px;
            height: 2px;
            top: 19px;
        }
        #crosshair .vertical {
            width: 2px;
            height: 40px;
            left: 19px;
        }
        #crosshair .circle {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(0, 223, 255, 0.7);
            border-radius: 50%;
            top: 13px;
            left: 13px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <!-- Crosshair -->
    <div id="crosshair">
        <div class="lines horizontal"></div>
        <div class="lines vertical"></div>
        <div class="circle"></div>
    </div>
    
    <!-- Flight Controls Panel -->
    <div id="controls" class="cockpit-panel">
        <h3>Flight Controls</h3>
        <p>W/S - Pitch up/down</p>
        <p>A/D - Roll left/right</p>
        <p>Q/E - Yaw left/right</p>
        <p>Shift - Boost</p>
        <p>Space - Fire weapons</p>
        <button id="toggle-instructions">Hide Controls</button>
    </div>
    
    <!-- Environment Selector Panel -->
    <div id="environment-selector" class="cockpit-panel">
        <h3>Environment</h3>
        <select id="environment">
            <option value="ocean">Ocean</option>
            <option value="forest">Forest</option>
            <option value="city">City</option>
        </select>
        <button id="apply-environment">Change Terrain</button>
    </div>
    
    <!-- Time Control Panel -->
    <div id="time-control" class="cockpit-panel">
        <h3>Time of Day</h3>
        <input type="range" id="time-slider" min="0" max="24" value="12" step="0.1">
        <p id="time-display">12:00</p>
        <button id="auto-cycle">Auto Cycle: Off</button>
    </div>
    
    <!-- Primary Flight Display -->
    <div id="ui" class="cockpit-panel">
        <div id="speed">Speed: 0 km/h</div>
        <div id="altitude">Altitude: 0 m</div>
        <div id="ammo">Ammo: 1000</div>
    </div>
    
    <!-- Loading Screen -->
    <div id="loading">
        <div style="text-align: center;">
            <h2>Loading WW2 Fighter Plane Simulator</h2>
            <div class="progress">
                <div id="progress-bar" class="progress-bar"></div>
            </div>
            <p id="loading-status">Loading assets...</p>
        </div>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.8); z-index: 2000; flex-direction: column; justify-content: center; align-items: center; color: #f00; font-family: 'Rajdhani', sans-serif;">
        <h1 style="font-size: 48px; margin-bottom: 20px; text-shadow: 0 0 10px #f00;">PLANE CRASHED</h1>
        <p id="crash-reason" style="font-size: 24px; margin-bottom: 30px;">You crashed into the ground</p>
        <button id="restart-button" style="padding: 10px 20px; background-color: #600; color: white; border: 2px solid #f00; font-size: 20px; cursor: pointer; border-radius: 5px; box-shadow: 0 0 10px #f00;">Restart Mission</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.162.0/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.162.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { Water } from 'three/addons/objects/Water.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        
        // Global variables
        let camera, scene, renderer, composer;
        let planeMesh, planeObject, propeller;
        let water, sky, sun;
        let forest, city;
        let currentEnvironment = 'ocean';
        let clock = new THREE.Clock();
        let keyStates = {};
        let velocity = new THREE.Vector3();
        let acceleration = 0;
        let yawVelocity = 0;
        let pitchVelocity = 0;
        let rollVelocity = 0;
        let maxSpeed = 100;
        let drag = 0.95;
        let ammo = 1000;
        let machineGunSound, engineSound, explosionSound;
        let particles = [];
        let bullets = [];
        let clouds = [];
        let autoCycle = false;
        let timeOfDay = 12; // 24-hour format
        let dayLength = 300; // seconds for a full day cycle
        let targets = [];
        let loadingManager = new THREE.LoadingManager();
        let totalItems = 10; // Approximate number of items to load
        let loadedItems = 0;
        
        // Setup loading manager
        loadingManager.onProgress = function(url, itemsLoaded, itemsTotal) {
            loadedItems++;
            const progressBar = document.getElementById('progress-bar');
            const loadingStatus = document.getElementById('loading-status');
            const progress = Math.min(loadedItems / totalItems * 100, 100);
            progressBar.style.width = progress + '%';
            loadingStatus.textContent = `Loading asset ${loadedItems} of ${totalItems}...`;
        };
        
        loadingManager.onLoad = function() {
            const loadingScreen = document.getElementById('loading');
            loadingScreen.style.display = 'none';
            // Start engine sound when loaded
            if (engineSound) {
                engineSound.play();
            }
        };
        
        // Initialize the scene, camera, and renderer
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xaaaaaa, 0.0007);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100000);
            camera.position.set(0, 10, 30);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 0.5;
            renderer.shadowMap.enabled = true;
            
            // Post-processing setup
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.5,  // bloom strength
                0.4,  // bloom radius
                0.85  // bloom threshold
            );
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            
            // Load plane model
            loadPlane();
            
            // Create sky and lighting
            createSky();
            createLighting();
            
            // Create environments
            createOcean();
            createForest();
            createCity();
            
            // Apply initial environment
            setEnvironment('ocean');
            
            // Create clouds
            createClouds();
            
            // Create target practice objects
            createTargets();
            
            // Load audio
            loadAudio();
            
            // Add event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            document.getElementById('toggle-instructions').addEventListener('click', function() {
                const controls = document.getElementById('controls');
                if (controls.style.display === 'none') {
                    controls.style.display = 'block';
                    this.textContent = 'Hide Controls';
                } else {
                    controls.style.display = 'none';
                    this.textContent = 'Show Controls';
                }
            });
            
            document.getElementById('apply-environment').addEventListener('click', function() {
                const env = document.getElementById('environment').value;
                setEnvironment(env);
            });
            
            document.getElementById('time-slider').addEventListener('input', function() {
                timeOfDay = parseFloat(this.value);
                document.getElementById('time-display').textContent = formatTime(timeOfDay);
                updateSunPosition();
            });
            
            document.getElementById('auto-cycle').addEventListener('click', function() {
                autoCycle = !autoCycle;
                this.textContent = autoCycle ? 'Auto Cycle: On' : 'Auto Cycle: Off';
            });
            
            // Setup restart button functionality 
            document.getElementById('restart-button').addEventListener('click', function() {
                location.reload();
            });
        }
        
        function formatTime(time) {
            const hours = Math.floor(time);
            const minutes = Math.floor((time - hours) * 60);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }
        
        function loadPlane() {
            const loader = new GLTFLoader(loadingManager);
            // Using a placeholder model URL - replace with an actual WW2 fighter plane model
            const planeUrl = 'https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/models/gltf/Soldier.glb';
            
            loader.load(planeUrl, function(gltf) {
                planeObject = gltf.scene;
                planeObject.scale.set(0.02, 0.02, 0.02);
                planeObject.rotation.y = Math.PI;
                
                // Create a simple plane mesh as a placeholder until we get a proper model
                const geometry = new THREE.BoxGeometry(2, 0.5, 4);
                const material = new THREE.MeshStandardMaterial({ color: 0x888888 });
                planeMesh = new THREE.Mesh(geometry, material);
                planeMesh.castShadow = true;
                planeMesh.receiveShadow = true;
                
                // Add wings
                const wingGeometry = new THREE.BoxGeometry(8, 0.1, 1);
                const wingMesh = new THREE.Mesh(wingGeometry, material);
                wingMesh.position.set(0, 0, 0);
                planeMesh.add(wingMesh);
                
                // Add tail
                const tailGeometry = new THREE.BoxGeometry(2, 0.4, 0.5);
                const tailMesh = new THREE.Mesh(tailGeometry, material);
                tailMesh.position.set(0, 0.2, -1.8);
                planeMesh.add(tailMesh);
                
                // Add vertical stabilizer
                const stabilizerGeometry = new THREE.BoxGeometry(0.1, 0.8, 1);
                const stabilizerMesh = new THREE.Mesh(stabilizerGeometry, material);
                stabilizerMesh.position.set(0, 0.4, -1.8);
                planeMesh.add(stabilizerMesh);
                
                // Add propeller
                const propellerGeometry = new THREE.BoxGeometry(2.5, 0.1, 0.2);
                const propellerMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
                propeller = new THREE.Mesh(propellerGeometry, propellerMaterial);
                propeller.position.set(0, 0, 2.1);
                planeMesh.add(propeller);
                
                // Add machine guns (visual representation)
                const gunGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
                const gunMaterial = new THREE.MeshStandardMaterial({ color: 0x111111 });
                
                const leftGun = new THREE.Mesh(gunGeometry, gunMaterial);
                leftGun.rotation.x = Math.PI / 2;
                leftGun.position.set(-1, 0, 1.5);
                planeMesh.add(leftGun);
                
                const rightGun = new THREE.Mesh(gunGeometry, gunMaterial);
                rightGun.rotation.x = Math.PI / 2;
                rightGun.position.set(1, 0, 1.5);
                planeMesh.add(rightGun);
                
                // Set initial position - start higher up to avoid immediate crash
                planeMesh.position.set(0, 200, 0);
                
                scene.add(planeMesh);
                
            }, function(xhr) {
                // Progress callback
            }, function(error) {
                console.error('Error loading plane model:', error);
            });
        }
        
        function createSky() {
            // Sky
            sky = new Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);
            
            sun = new THREE.Vector3();
            
            // Add a directional light to represent the sun
            const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
            sunLight.position.set(0, 100, 0);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 500;
            sunLight.shadow.camera.left = -100;
            sunLight.shadow.camera.right = 100;
            sunLight.shadow.camera.top = 100;
            sunLight.shadow.camera.bottom = -100;
            scene.add(sunLight);
            
            // Update sky based on time of day
            updateSunPosition();
        }
        
        function updateSunPosition() {
            // Convert 24-hour time to phi value (0-2π)
            const phi = (timeOfDay / 24) * Math.PI * 2;
            
            // Calculate sun position
            const theta = Math.PI * (0.25 - 0.5 + 0.5); // Keep sun in the southern half
            
            sun.x = Math.cos(phi) * Math.cos(theta) * 100000;
            sun.y = Math.sin(phi) * 100000;
            sun.z = Math.cos(phi) * Math.sin(theta) * 100000;
            
            sky.material.uniforms['sunPosition'].value.copy(sun);
            
            // Update directional light to match sun position
            const sunLight = scene.children.find(child => child instanceof THREE.DirectionalLight);
            if (sunLight) {
                sunLight.position.copy(sun.clone().normalize().multiplyScalar(100));
                
                // Adjust light intensity and color based on time of day
                const sunHeight = sun.y / 100000; // -1 to 1
                
                if (sunHeight > 0) {
                    // Day
                    const intensity = 1.5 * Math.max(0.5, sunHeight);
                    sunLight.intensity = intensity;
                    sunLight.color.setHSL(0.1, 0.7, 0.5 + 0.5 * sunHeight);
                    scene.fog.color.setHSL(0.6, 0.2, Math.max(0.3, 0.5 * sunHeight + 0.5));
                } else {
                    // Night
                    const intensity = 0.5 * Math.max(0.1, 1 + sunHeight);
                    sunLight.intensity = intensity;
                    sunLight.color.setHSL(0.15, 0.5, 0.2);
                    scene.fog.color.setHSL(0.2, 0.2, Math.max(0.05, -sunHeight * 0.2 + 0.1));
                }
                
                // Add moon light at night
                if (sunHeight < 0) {
                    scene.add(new THREE.HemisphereLight(0x030311, 0x000000, 0.2));
                }
            }
            
            // Update water reflectivity if water exists
            if (water) {
                water.material.uniforms['sunDirection'].value.copy(sun.clone().normalize());
            }
        }
        
        function createLighting() {
            // Ambient light for general illumination
            const ambientLight = new THREE.AmbientLight(0x333333);
            scene.add(ambientLight);
            
            // Hemisphere light for sky/ground color
            const hemisphereLight = new THREE.HemisphereLight(0xaaaaff, 0x334433, 0.6);
            scene.add(hemisphereLight);
        }
        
        function createOcean() {
            // Water
            const waterGeometry = new THREE.PlaneGeometry(100000, 100000);
            water = new Water(waterGeometry, {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: new THREE.TextureLoader(loadingManager).load(
                    'https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/textures/waternormals.jpg',
                    function(texture) {
                        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                    }
                ),
                sunDirection: new THREE.Vector3(),
                sunColor: 0xffffff,
                waterColor: 0x001e0f,
                distortionScale: 3.7,
                fog: scene.fog !== undefined
            });
            water.rotation.x = -Math.PI / 2;
            water.position.y = -5;
            water.visible = false;
            scene.add(water);
        }
        
        function createForest() {
            forest = new THREE.Group();
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100000, 100000);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x2d4c1e });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            forest.add(ground);
            
            // Add trees
            const treeCount = 5000;
            const treeSpread = 10000;
            
            for (let i = 0; i < treeCount; i++) {
                createTree(
                    (Math.random() - 0.5) * treeSpread,
                    0,
                    (Math.random() - 0.5) * treeSpread,
                    forest
                );
            }
            
            // Add some hills/mountains
            for (let i = 0; i < 50; i++) {
                const size = 500 + Math.random() * 2000;
                const height = 100 + Math.random() * 300;
                
                const hillGeometry = new THREE.ConeGeometry(size, height, 5 + Math.floor(Math.random() * 5));
                const hillMaterial = new THREE.MeshStandardMaterial({ color: 0x2d3d1e });
                const hill = new THREE.Mesh(hillGeometry, hillMaterial);
                
                hill.position.set(
                    (Math.random() - 0.5) * treeSpread,
                    -height / 2,
                    (Math.random() - 0.5) * treeSpread
                );
                
                hill.rotation.y = Math.random() * Math.PI;
                hill.receiveShadow = true;
                hill.castShadow = true;
                
                forest.add(hill);
            }
            
            forest.visible = false;
            scene.add(forest);
        }
        
        function createTree(x, y, z, parent) {
            // Tree trunk
            const trunkGeometry = new THREE.CylinderGeometry(2, 3, 15, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.set(x, y + 7.5, z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            
            // Tree leaves
            const leavesGeometry = new THREE.ConeGeometry(10, 25, 8);
            const leavesMaterial = new THREE.MeshStandardMaterial({ color: 0x2d5d1e });
            const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
            leaves.position.set(0, 15, 0);
            leaves.castShadow = true;
            
            trunk.add(leaves);
            parent.add(trunk);
        }
        
        function createCity() {
            city = new THREE.Group();
            
            // Ground
            const groundGeometry = new THREE.PlaneGeometry(100000, 100000);
            const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            city.add(ground);
            
            // Create grid of buildings
            const gridSize = 20;
            const spacing = 150;
            const offset = gridSize * spacing / 2;
            
            for (let x = 0; x < gridSize; x++) {
                for (let z = 0; z < gridSize; z++) {
                    // Skip some positions to create roads
                    if (x % 4 === 0 || z % 4 === 0) continue;
                    
                    // Create a building
                    const height = 20 + Math.random() * 100;
                    const width = 30 + Math.random() * 30;
                    const depth = 30 + Math.random() * 30;
                    
                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                    const buildingMaterial = new THREE.MeshStandardMaterial({
                        color: new THREE.Color(0.6 + Math.random() * 0.4, 0.6 + Math.random() * 0.4, 0.6 + Math.random() * 0.4)
                    });
                    
                    const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
                    building.position.set(
                        x * spacing - offset,
                        height / 2,
                        z * spacing - offset
                    );
                    
                    building.castShadow = true;
                    building.receiveShadow = true;
                    
                    city.add(building);
                }
            }
            
            city.visible = false;
            scene.add(city);
        }
        
        function createClouds() {
            const cloudCount = 100;
            const cloudSpread = 10000;
            const cloudHeight = 1000;
            const cloudHeightVariation = 500;
            
            for (let i = 0; i < cloudCount; i++) {
                const cloud = new THREE.Group();
                
                // Create cluster of spheres for each cloud
                const clusterCount = 3 + Math.floor(Math.random() * 7);
                const clusterSize = 50 + Math.random() * 100;
                
                for (let j = 0; j < clusterCount; j++) {
                    const size = clusterSize * (0.5 + Math.random() * 0.5);
                    const cloudPartGeometry = new THREE.SphereGeometry(size, 7, 7);
                    const cloudPartMaterial = new THREE.MeshStandardMaterial({
                        color: 0xffffff,
                        transparent: true,
                        opacity: 0.8,
                        flatShading: true
                    });
                    
                    const cloudPart = new THREE.Mesh(cloudPartGeometry, cloudPartMaterial);
                    cloudPart.position.set(
                        (Math.random() - 0.5) * clusterSize * 2,
                        (Math.random() - 0.5) * clusterSize * 0.5,
                        (Math.random() - 0.5) * clusterSize * 2
                    );
                    
                    cloud.add(cloudPart);
                }
                
                cloud.position.set(
                    (Math.random() - 0.5) * cloudSpread,
                    cloudHeight + (Math.random() - 0.5) * cloudHeightVariation,
                    (Math.random() - 0.5) * cloudSpread
                );
                
                scene.add(cloud);
                clouds.push({
                    mesh: cloud,
                    speed: 0.2 + Math.random() * 0.8,
                    dirX: Math.random() - 0.5,
                    dirZ: Math.random() - 0.5
                });
            }
            
            // Set up cloud generation interval
            setInterval(() => {
                // Add new clouds occasionally
                if (clouds.length < 150) {
                    const edge = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left
                    let x, z;
                    const dirX = Math.random() - 0.5;
                    const dirZ = Math.random() - 0.5;
                    
                    // Position new clouds at the edges of the visible area
                    if (edge === 0) {
                        x = (Math.random() - 0.5) * cloudSpread;
                        z = -cloudSpread/2;
                    } else if (edge === 1) {
                        x = cloudSpread/2;
                        z = (Math.random() - 0.5) * cloudSpread;
                    } else if (edge === 2) {
                        x = (Math.random() - 0.5) * cloudSpread;
                        z = cloudSpread/2;
                    } else {
                        x = -cloudSpread/2;
                        z = (Math.random() - 0.5) * cloudSpread;
                    }
                    
                    // Create a new cloud
                    const cloud = new THREE.Group();
                    const clusterCount = 3 + Math.floor(Math.random() * 7);
                    const clusterSize = 50 + Math.random() * 100;
                    
                    for (let j = 0; j < clusterCount; j++) {
                        const size = clusterSize * (0.5 + Math.random() * 0.5);
                        const cloudPartGeometry = new THREE.SphereGeometry(size, 7, 7);
                        const cloudPartMaterial = new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0.8,
                            flatShading: true
                        });
                        
                        const cloudPart = new THREE.Mesh(cloudPartGeometry, cloudPartMaterial);
                        cloudPart.position.set(
                            (Math.random() - 0.5) * clusterSize * 2,
                            (Math.random() - 0.5) * clusterSize * 0.5,
                            (Math.random() - 0.5) * clusterSize * 2
                        );
                        
                        cloud.add(cloudPart);
                    }
                    
                    cloud.position.set(
                        x,
                        cloudHeight + (Math.random() - 0.5) * cloudHeightVariation,
                        z
                    );
                    
                    scene.add(cloud);
                    clouds.push({
                        mesh: cloud,
                        speed: 0.2 + Math.random() * 0.8,
                        dirX: dirX,
                        dirZ: dirZ
                    });
                }
            }, 5000);
        }
        
        function createTargets() {
            // Create some flying targets for shooting practice
            const targetCount = 20;
            const targetSpread = 5000;
            
            for (let i = 0; i < targetCount; i++) {
                // Create a simple target - will be replaced with better models later
                const targetGeometry = new THREE.BoxGeometry(20, 5, 20);
                const targetMaterial = new THREE.MeshStandardMaterial({ color: 0x883333 });
                const target = new THREE.Mesh(targetGeometry, targetMaterial);
                
                // Position randomly
                target.position.set(
                    (Math.random() - 0.5) * targetSpread,
                    200 + Math.random() * 400,
                    (Math.random() - 0.5) * targetSpread
                );
                
                target.userData = {
                    type: 'target',
                    health: 100,
                    speed: 5 + Math.random() * 10,
                    direction: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 2
                    ).normalize()
                };
                
                scene.add(target);
                targets.push(target);
            }
            
            // Set up target respawn interval
            setInterval(() => {
                // Add new targets occasionally 
                if (targets.length < 15) {
                    const spawnDistance = 3000;
                    const angle = Math.random() * Math.PI * 2;
                    
                    // Position based on a circle around the current player position
                    let spawnX, spawnZ;
                    if (planeMesh) {
                        spawnX = planeMesh.position.x + Math.cos(angle) * spawnDistance;
                        spawnZ = planeMesh.position.z + Math.sin(angle) * spawnDistance;
                    } else {
                        spawnX = (Math.random() - 0.5) * targetSpread;
                        spawnZ = (Math.random() - 0.5) * targetSpread;
                    }
                    
                    // Create a new target
                    const targetGeometry = new THREE.BoxGeometry(20, 5, 20);
                    const targetMaterial = new THREE.MeshStandardMaterial({ color: 0x883333 });
                    const target = new THREE.Mesh(targetGeometry, targetMaterial);
                    
                    target.position.set(
                        spawnX,
                        200 + Math.random() * 400,
                        spawnZ
                    );
                    
                    target.userData = {
                        type: 'target',
                        health: 100,
                        speed: 5 + Math.random() * 10,
                        direction: new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 2
                        ).normalize()
                    };
                    
                    scene.add(target);
                    targets.push(target);
                }
            }, 5000);
        }
        
        function loadAudio() {
            // Create an audio listener
            const listener = new THREE.AudioListener();
            camera.add(listener);
            
            // Machine gun sound
            machineGunSound = new THREE.Audio(listener);
            const machineGunAudioLoader = new THREE.AudioLoader(loadingManager);
            machineGunAudioLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/sounds/376088__daleonfire__machine-gun-firing.mp3', function(buffer) {
                machineGunSound.setBuffer(buffer);
                machineGunSound.setVolume(0.5);
                machineGunSound.setLoop(true);
            });
            
            // Engine sound
            engineSound = new THREE.Audio(listener);
            const engineAudioLoader = new THREE.AudioLoader(loadingManager);
            engineAudioLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/sounds/376737__waveplaySFX__jet-engine-startup-idle-in-cockpit.mp3', function(buffer) {
                engineSound.setBuffer(buffer);
                engineSound.setVolume(0.3);
                engineSound.setLoop(true);
            });
            
            // Explosion sound
            explosionSound = new THREE.Audio(listener);
            const explosionAudioLoader = new THREE.AudioLoader(loadingManager);
            explosionAudioLoader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@master/examples/sounds/191694__giddster__explosion.mp3', function(buffer) {
                explosionSound.setBuffer(buffer);
                explosionSound.setVolume(0.5);
            });
        }
        
        function setEnvironment(env) {
            currentEnvironment = env;
            
            // Hide all environments
            water.visible = false;
            forest.visible = false;
            city.visible = false;
            
            // Show the selected environment
            if (env === 'ocean') {
                water.visible = true;
                scene.fog.density = 0.0005;
            } else if (env === 'forest') {
                forest.visible = true;
                scene.fog.density = 0.001;
            } else if (env === 'city') {
                city.visible = true;
                scene.fog.density = 0.002;
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onKeyDown(event) {
            keyStates[event.code] = true;
        }
        
        function onKeyUp(event) {
            keyStates[event.code] = false;
            
            // Handle firing machine guns
            if (event.code === 'Space') {
                stopFiring();
            }
        }
        
        function fireMachineGuns() {
            if (ammo <= 0) return;
            
            // Play machine gun sound if not already playing
            if (machineGunSound && !machineGunSound.isPlaying) {
                machineGunSound.play();
            }
            
            // Create muzzle flash effect
            createMuzzleFlash();
            
            // Create bullet trajectory
            const bulletSpeed = 500;
            
            // Left gun
            createBullet(new THREE.Vector3(-1, 0, 1.5), bulletSpeed);
            
            // Right gun
            createBullet(new THREE.Vector3(1, 0, 1.5), bulletSpeed);
            
            // Reduce ammo
            ammo -= 2;
            document.getElementById('ammo').textContent = `Ammo: ${ammo}`;
        }
        
        function stopFiring() {
            if (machineGunSound && machineGunSound.isPlaying) {
                machineGunSound.stop();
            }
        }
        
        function createMuzzleFlash() {
            if (!planeMesh) return;
            
            // Create a point light for each gun
            const leftFlash = new THREE.PointLight(0xff9933, 5, 5);
            leftFlash.position.set(-1, 0, 2);
            planeMesh.add(leftFlash);
            
            const rightFlash = new THREE.PointLight(0xff9933, 5, 5);
            rightFlash.position.set(1, 0, 2);
            planeMesh.add(rightFlash);
            
            // Remove after a short delay
            setTimeout(() => {
                planeMesh.remove(leftFlash);
                planeMesh.remove(rightFlash);
            }, 50);
        }
        
        function createBullet(offsetPosition, speed) {
            if (!planeMesh) return;
            
            // Convert local position to world position
            const bulletPosition = new THREE.Vector3();
            bulletPosition.copy(offsetPosition);
            bulletPosition.applyMatrix4(planeMesh.matrixWorld);
            
            // Create tracer bullet effect
            const bulletGeometry = new THREE.BoxGeometry(0.05, 0.05, 0.8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            // Get plane's forward direction
            const direction = new THREE.Vector3(0, 0, 1);
            direction.applyQuaternion(planeMesh.quaternion);
            
            // Position bullet
            bullet.position.copy(bulletPosition);
            bullet.quaternion.copy(planeMesh.quaternion);
            
            // Add point light to simulate tracer
            const bulletLight = new THREE.PointLight(0xffff33, 2, 3);
            bullet.add(bulletLight);
            
            scene.add(bullet);
            
            bullets.push({
                mesh: bullet,
                direction: direction,
                speed: speed,
                timeAlive: 0
            });
        }
        
        function updateBullets(delta) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                
                // Move bullet
                bullet.mesh.position.addScaledVector(bullet.direction, bullet.speed * delta);
                
                // Update lifetime
                bullet.timeAlive += delta;
                
                // Check for collisions with targets
                checkBulletCollisions(bullet);
                
                // Remove old bullets
                if (bullet.timeAlive > 2) {
                    scene.remove(bullet.mesh);
                    bullets.splice(i, 1);
                }
            }
        }
        
        function checkBulletCollisions(bullet) {
            for (let i = targets.length - 1; i >= 0; i--) {
                const target = targets[i];
                
                // Simple distance-based collision detection
                if (bullet.mesh.position.distanceTo(target.position) < 15) {
                    // Target hit!
                    target.userData.health -= 20;
                    
                    // Create hit effect
                    createHitEffect(bullet.mesh.position);
                    
                    // Remove the bullet
                    scene.remove(bullet.mesh);
                    const bulletIndex = bullets.indexOf(bullet);
                    if (bulletIndex !== -1) {
                        bullets.splice(bulletIndex, 1);
                    }
                    
                    // Check if target is destroyed
                    if (target.userData.health <= 0) {
                        createExplosion(target.position);
                        scene.remove(target);
                        targets.splice(i, 1);
                        
                        // Play explosion sound
                        if (explosionSound && !explosionSound.isPlaying) {
                            explosionSound.play();
                        }
                    }
                    
                    break;
                }
            }
        }
        
        function createHitEffect(position) {
            // Create a flash of light
            const hitLight = new THREE.PointLight(0xff5500, 5, 10);
            hitLight.position.copy(position);
            scene.add(hitLight);
            
            // Remove after a short time
            setTimeout(() => {
                scene.remove(hitLight);
            }, 100);
            
            // Add particle effect
            const particleCount = 10;
            for (let i = 0; i < particleCount; i++) {
                createParticle(position, 0xff5500, 0.2, 1);
            }
        }
        
        function createExplosion(position) {
            // Create a bright flash
            const explosionLight = new THREE.PointLight(0xff9900, 10, 100);
            explosionLight.position.copy(position);
            scene.add(explosionLight);
            
            // Create a sphere for the explosion
            const explosionGeometry = new THREE.SphereGeometry(10, 20, 20);
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff9900,
                transparent: true,
                opacity: 0.8
            });
            
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(position);
            scene.add(explosion);
            
            // Animate expansion then removal
            let scale = 1.0;
            const expandAnimation = setInterval(() => {
                scale += 0.2;
                explosion.scale.set(scale, scale, scale);
                explosionMaterial.opacity -= 0.05;
                
                if (scale >= 5) {
                    clearInterval(expandAnimation);
                    scene.remove(explosion);
                    scene.remove(explosionLight);
                }
            }, 50);
            
            // Generate particles
            const particleCount = 50;
            for (let i = 0; i < particleCount; i++) {
                createParticle(position, 0xff5500, 1, 3);
            }
        }
        
        function createParticle(position, color, size, lifetime) {
            const particleGeometry = new THREE.BoxGeometry(size, size, size);
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 1.0
            });
            
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            particle.position.copy(position);
            
            // Randomize direction
            const direction = new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2,
                (Math.random() - 0.5) * 2
            ).normalize();
            
            const speed = 5 + Math.random() * 15;
            
            scene.add(particle);
            
            particles.push({
                mesh: particle,
                direction: direction,
                speed: speed,
                timeAlive: 0,
                lifetime: lifetime,
                material: particleMaterial
            });
        }
        
        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                
                // Move particle
                particle.mesh.position.addScaledVector(particle.direction, particle.speed * delta);
                
                // Slow down over time
                particle.speed *= 0.98;
                
                // Update lifetime
                particle.timeAlive += delta;
                
                // Fade out
                particle.material.opacity = 1 - (particle.timeAlive / particle.lifetime);
                
                // Remove old particles
                if (particle.timeAlive >= particle.lifetime) {
                    scene.remove(particle.mesh);
                    particles.splice(i, 1);
                }
            }
        }
        
        function createExhaustSmoke() {
            if (!planeMesh) return;
            
            // Get position behind the plane
            const exhaustPosition = new THREE.Vector3(0, 0, -2);
            exhaustPosition.applyMatrix4(planeMesh.matrixWorld);
            
            // Create smoke particle
            const size = 0.2 + Math.random() * 0.3;
            const smokeColor = acceleration > 5 ? 0x333333 : 0x999999; // Darker when accelerating
            
            createParticle(exhaustPosition, smokeColor, size, 2 + Math.random());
        }
        
        function createLensFlare() {
            if (!planeMesh) return;
            
            // Check if sun is visible to create lens flare
            const sunPosition = sun.clone().normalize();
            
            // Get direction from camera to plane
            const planeDirection = new THREE.Vector3();
            planeDirection.subVectors(planeMesh.position, camera.position).normalize();
            
            // Calculate angle between sun and plane direction
            const angle = planeDirection.angleTo(sunPosition);
            
            if (angle < 0.5) {  // If sun is roughly in front of the plane
                // Add a lens flare effect (simple version - a bright plane)
                const flareGeometry = new THREE.PlaneGeometry(30, 30);
                const flareMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffff99,
                    transparent: true,
                    opacity: 0.4 * (1 - angle / 0.5),
                    side: THREE.DoubleSide
                });
                
                const flare = new THREE.Mesh(flareGeometry, flareMaterial);
                
                // Position in front of camera
                const distance = 10;
                flare.position.copy(camera.position);
                flare.position.addScaledVector(camera.getWorldDirection(new THREE.Vector3()), distance);
                
                // Make flare face camera
                flare.lookAt(camera.position);
                
                scene.add(flare);
                
                // Remove after a short time
                setTimeout(() => {
                    scene.remove(flare);
                }, 100);
            }
        }
        
        function updateTargets(delta) {
            for (const target of targets) {
                // Move target
                target.position.addScaledVector(target.userData.direction, target.userData.speed * delta);
                
                // Slightly change direction occasionally
                if (Math.random() < 0.01) {
                    target.userData.direction.x += (Math.random() - 0.5) * 0.2;
                    target.userData.direction.y += (Math.random() - 0.5) * 0.05;
                    target.userData.direction.z += (Math.random() - 0.5) * 0.2;
                    target.userData.direction.normalize();
                }
                
                // Keep within bounds
                const bounds = 5000;
                if (Math.abs(target.position.x) > bounds || 
                    Math.abs(target.position.y - 300) > bounds || 
                    Math.abs(target.position.z) > bounds) {
                    // Turn back towards center
                    target.userData.direction.set(
                        -target.position.x,
                        300 - target.position.y,
                        -target.position.z
                    ).normalize();
                }
            }
        }
        
        function updateClouds(delta) {
            for (let i = clouds.length - 1; i >= 0; i--) {
                const cloud = clouds[i];
                
                // Move clouds in their direction
                cloud.mesh.position.x += cloud.dirX * cloud.speed * delta * 10;
                cloud.mesh.position.z += cloud.dirZ * cloud.speed * delta * 10;
                
                // Check if cloud is too far away
                const maxDistance = 15000;
                if (
                    cloud.mesh.position.x > maxDistance ||
                    cloud.mesh.position.x < -maxDistance ||
                    cloud.mesh.position.z > maxDistance ||
                    cloud.mesh.position.z < -maxDistance
                ) {
                    // Remove the cloud
                    scene.remove(cloud.mesh);
                    clouds.splice(i, 1);
                }
            }
        }
        
        function updatePlane(delta) {
            if (!planeMesh) return;
            
            // Handle keyboard controls
            if (keyStates['KeyW']) {
                pitchVelocity += 1 * delta;
                // Update crosshair for pitch up
                document.querySelector('#crosshair').style.transform = 'translate(-50%, calc(-50% - 5px))';
            } else if (keyStates['KeyS']) {
                pitchVelocity -= 1 * delta;
                // Update crosshair for pitch down
                document.querySelector('#crosshair').style.transform = 'translate(-50%, calc(-50% + 5px))';
            } else {
                // Reset crosshair position
                document.querySelector('#crosshair').style.transform = 'translate(-50%, -50%)';
            }
            
            if (keyStates['KeyA']) {
                rollVelocity -= 1.5 * delta;
                // Visual effect for rolling
                document.querySelector('#crosshair').style.transform += ' rotate(-10deg)';
            }
            if (keyStates['KeyD']) {
                rollVelocity += 1.5 * delta;
                // Visual effect for rolling
                document.querySelector('#crosshair').style.transform += ' rotate(10deg)';
            }
            if (keyStates['KeyQ']) {
                yawVelocity -= 1 * delta;
            }
            if (keyStates['KeyE']) {
                yawVelocity += 1 * delta;
            }
            if (keyStates['ShiftLeft'] || keyStates['ShiftRight']) {
                acceleration = 10;
                // Visual boost effect
                document.querySelector('#ui').style.textShadow = '0 0 8px #0df';
            } else {
                acceleration = 5;
                document.querySelector('#ui').style.textShadow = 'none';
            }
            
            // Fire weapons
            if (keyStates['Space']) {
                fireMachineGuns();
                // Visual effect when firing
                document.querySelector('#crosshair').style.boxShadow = '0 0 15px rgba(255, 150, 0, 0.7)';
                setTimeout(() => {
                    document.querySelector('#crosshair').style.boxShadow = 'none';
                }, 50);
            }
            
            // Apply drag to the rotational velocities
            pitchVelocity *= 0.9;
            rollVelocity *= 0.9;
            yawVelocity *= 0.9;
            
            // Clamp rotational velocities
            pitchVelocity = Math.max(-1, Math.min(1, pitchVelocity));
            rollVelocity = Math.max(-1.5, Math.min(1.5, rollVelocity));
            yawVelocity = Math.max(-1, Math.min(1, yawVelocity));
            
            // Apply rotations
            planeMesh.rotation.x += pitchVelocity * delta * 2;
            planeMesh.rotation.z += rollVelocity * delta * 2;
            planeMesh.rotation.y += yawVelocity * delta * 2;
            
            // Calculate forward direction
            const forward = new THREE.Vector3(0, 0, 1);
            forward.applyQuaternion(planeMesh.quaternion);
            
            // Apply velocity in the forward direction
            velocity.copy(forward).multiplyScalar(acceleration);
            planeMesh.position.add(velocity);
            
            // Rotate propeller
            if (propeller) {
                propeller.rotation.z += 20 * delta * (acceleration / 5);
            }
            
            // Create exhaust smoke occasionally
            if (Math.random() < 0.3) {
                createExhaustSmoke();
            }
            
            // Add lens flare effect occasionally
            if (Math.random() < 0.05) {
                createLensFlare();
            }
            
            // Check for ground collision
            checkGroundCollision();
            
            // Update camera to follow plane
            updateCamera();
            
            // Update UI displays with formatted text
            document.getElementById('speed').textContent = `Speed: ${Math.round(acceleration * 20)} km/h`;
            document.getElementById('altitude').textContent = `Altitude: ${Math.round(planeMesh.position.y)} m`;
            
            // Add a slight shake to the UI when at high speeds or low altitudes
            if (acceleration > 7 || planeMesh.position.y < 50) {
                const shake = acceleration > 7 ? (acceleration - 7) * 0.5 : (50 - planeMesh.position.y) * 0.03;
                document.querySelectorAll('.cockpit-panel').forEach(panel => {
                    panel.style.transform = `translate(${(Math.random() - 0.5) * shake}px, ${(Math.random() - 0.5) * shake}px)`;
                });
            } else {
                document.querySelectorAll('.cockpit-panel').forEach(panel => {
                    panel.style.transform = 'translate(0, 0)';
                });
            }
        }
        
        function checkGroundCollision() {
            if (!planeMesh) return;
            
            let groundLevel = 0;
            let crashReason = "";
            
            // Determine ground level based on current environment
            if (currentEnvironment === 'ocean') {
                groundLevel = -5; // Water level
                crashReason = "You crashed into the ocean";
            } else if (currentEnvironment === 'forest' || currentEnvironment === 'city') {
                groundLevel = 0; // Ground level
                crashReason = currentEnvironment === 'forest' ? 
                    "You crashed into the forest" : 
                    "You crashed into the city";
            }
            
            // Check if plane is below ground level (with a small buffer)
            if (planeMesh.position.y < groundLevel + 5) {
                // Only trigger crash if we have a reasonable velocity
                // This prevents crash on startup
                const speed = velocity.length();
                if (speed > 1) {
                    // Plane crashed!
                    gameOver(crashReason);
                } else {
                    // Just push the plane back up slightly
                    planeMesh.position.y = groundLevel + 5;
                }
            }
            
            // Change UI warning color when getting close to ground
            if (planeMesh.position.y < groundLevel + 50) {
                // Start warning at 50m above ground
                const warningIntensity = 1 - ((planeMesh.position.y - groundLevel) / 50);
                
                document.getElementById('altitude').style.color = 
                    `rgb(${Math.floor(255 * warningIntensity)}, ${Math.floor(223 * (1-warningIntensity))}, ${Math.floor(255 * (1-warningIntensity))})`;
            } else {
                document.getElementById('altitude').style.color = '#0df';
            }
        }
        
        function gameOver(reason) {
            // Stop the game
            clock.stop();
            
            // Show game over screen
            document.getElementById('game-over').style.display = 'flex';
            document.getElementById('crash-reason').textContent = reason || "Your plane was destroyed";
            
            // Create explosion at plane position
            createExplosion(planeMesh.position);
            
            // Hide the plane
            planeMesh.visible = false;
            
            // Play explosion sound
            if (explosionSound && !explosionSound.isPlaying) {
                explosionSound.play();
            }
            
            // Stop engine sound
            if (engineSound && engineSound.isPlaying) {
                engineSound.stop();
            }
            
            // Add restart button functionality
            document.getElementById('restart-button').addEventListener('click', function() {
                location.reload();
            });
        }
        
        function updateCamera() {
            if (!planeMesh) return;
            
            // Position camera behind and slightly above the plane
            const relativeCameraOffset = new THREE.Vector3(0, 5, -20);
            const cameraOffset = relativeCameraOffset.applyMatrix4(planeMesh.matrixWorld);
            
            // Smoothly move camera to follow plane
            camera.position.lerp(cameraOffset, 0.1);
            camera.lookAt(planeMesh.position);
        }
        
        function updateWater() {
            if (water && water.visible) {
                water.material.uniforms['time'].value += 0.5 / 60.0;
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = Math.min(clock.getDelta(), 0.1);
            
            // Update time of day if auto cycle is enabled
            if (autoCycle) {
                timeOfDay += (delta / dayLength) * 24;
                if (timeOfDay >= 24) timeOfDay -= 24;
                
                document.getElementById('time-slider').value = timeOfDay;
                document.getElementById('time-display').textContent = formatTime(timeOfDay);
                updateSunPosition();
            }
            
            // Update game elements
            updatePlane(delta);
            updateBullets(delta);
            updateParticles(delta);
            updateTargets(delta);
            updateClouds(delta);
            updateWater();
            
            // Render the scene
            composer.render();
        }
        
        // Initialize and start animation
        init();
        animate();
    </script>
</body>
</html>