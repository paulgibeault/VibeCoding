// Check for enemy core attacks at end of turn
function checkEnemyCoreAttacks() {
    try {
        console.log("\n----- Checking Enemy Core Attacks -----");
        const eliminations = [];
        const processedCells = new Set();

        // Check all cores for possible attacks
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const cell = gameState.grid[y][x];
                if (!cell.token) continue;
                
                // Get the value and player of this core
                const tokenParts = cell.token.split('-');
                const player = parseInt(tokenParts[1]);
                const value = cell.value || (tokenParts[0] === 'energy' ? 1 : 2);
                
                // Check adjacent cells for weaker cores
                const adjacentCells = getAdjacentCells(x, y);
                adjacentCells.forEach(adjInfo => {
                    const adjCell = adjInfo.cell;
                    if (!adjCell.token) return;
                    
                    const adjTokenParts = adjCell.token.split('-');
                    const adjPlayer = parseInt(adjTokenParts[1]);
                    const adjValue = adjCell.value || (adjTokenParts[0] === 'energy' ? 1 : 2);
                    
                    // If adjacent core belongs to different player AND has lower value
                    if (adjPlayer !== player && value > adjValue) {
                        const posKey = `${adjInfo.x},${adjInfo.y}`;
                        if (processedCells.has(posKey)) return;
                        processedCells.add(posKey);
                        
                        console.log(`Found elimination at (${adjInfo.x}, ${adjInfo.y}): core value ${value} > ${adjValue}`);
                        eliminations.push({
                            x: adjInfo.x,
                            y: adjInfo.y,
                            token: adjCell.token,
                            tokenType: adjTokenParts[0],
                            player: adjPlayer,
                            eliminatedBy: player,
                            value: adjValue
                        });
                    }
                });
            }
        }
        
        if (eliminations.length > 0) {
            console.log(`Found ${eliminations.length} eliminations during end-of-turn check`);
            processEliminations(eliminations);
            return true;
        }
        
        console.log("No eliminations found during end-of-turn check");
        return false;
    } catch (error) {
        console.error("Error checking core attacks:", error);
        return false;
    }
}

// Finish the current turn
function finishTurn() {
    console.log("\n----- Turn Complete -----");
    logBoardState("Final ");
    console.log(`Charged tokens - P1: ${gameState.players[0].chargedTokens}, P2: ${gameState.players[1].chargedTokens}`);
    console.log(`Scores - P1: ${gameState.players[0].score}, P2: ${gameState.players[1].score}`);
    
    // Check for enemy core attacks before ending the turn
    if (checkEnemyCoreAttacks()) {
        console.log("Enemy core attacks processed, turn will end after animations");
        return; // processEliminations will call finishTurn again after animations
    }
    
    console.log("========== TURN END ==========\n");
    // Check for game end condition
    if (checkGameEnd()) return;
    
    // Switch to next player
    gameState.currentPlayer = 1 - gameState.currentPlayer;
    
    // Reset turn phase
    gameState.turnPhase = 'selecting';
    
    // Update UI
    updatePlayerCards();
    document.getElementById('gameStatus').textContent = `${gameState.players[gameState.currentPlayer].name}'s turn`;
    
    // Switch selection mode back to energy
    setSelectionMode('energy');
} 