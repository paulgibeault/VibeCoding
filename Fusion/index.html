<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Grid Game</title>
    <style>
        /* Mid-century modern inspired design with energy theme */
        :root {
            --primary-color: #FF5A5F;
            --secondary-color: #3ECDC1;
            --tertiary-color: #FFC857;
            --background-color: #2A3D45;
            --grid-color: #3F4E4F;
            --text-color: #EFF6E0;
            --player1-color: #FF5A5F;
            --player2-color: #3ECDC1;
            --player1-glow: rgba(255, 90, 95, 0.6);
            --player2-glow: rgba(62, 205, 193, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            margin: 0;
            box-sizing: border-box;
        }

        .game-container {
            width: 100%;
            max-width: 1400px;
            height: 90vh;
            background: radial-gradient(circle at center, #3a4e56, #23353B);
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            position: relative;
            margin: 0;
            display: flex;
            flex-direction: column;
        }

        .game-header {
            background: linear-gradient(135deg, var(--primary-color), #8a3236);
            padding: 15px;
            text-align: center;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }

        .game-header::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.05),
                rgba(255, 255, 255, 0.05) 10px,
                rgba(255, 255, 255, 0) 10px,
                rgba(255, 255, 255, 0) 20px
            );
        }

        .game-header h1 {
            font-weight: 700;
            letter-spacing: 3px;
            font-size: 2.4rem;
            margin-bottom: 5px;
            position: relative;
            text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.2);
        }

        .game-header p {
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
            font-weight: 300;
        }

        .game-content {
            display: flex;
            flex-direction: row;
            padding: 20px;
            position: relative;
            z-index: 1;
            gap: 20px;
            flex: 1;
            min-height: 0; /* Important for flex child */
        }

        /* Player Cards - Base Styles */
        .player-cards {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            width: 250px;
            min-width: 250px;
            flex-shrink: 0;
            gap: 15px;
        }

        Player Card Styling and Update Fixes

        // Fix 1: Consistent CSS for player cards
        // Add this to your CSS section (inside the <style> tag)

        /* Player Card Fixes */
        .player-card {
            background: rgba(42, 61, 69, 0.85);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            padding: 20px;
            width: 100%;
            min-height: 200px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3), 
                        0 2px 8px rgba(255, 255, 255, 0.1) inset;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.15);
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Clearer active state styling for player cards */
        .player1.active {
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4), 
                        0 0 25px var(--player1-glow);
            border: 2px solid var(--player1-color);
        }

        .player2.active {
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4), 
                        0 0 25px var(--player2-glow);
            border: 2px solid var(--player2-color);
        }

        /* Player card content styling */
        .player-name {
            font-size: 1.4rem;
            margin-bottom: 10px;
            position: relative;
            font-weight: 700;
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        .player-stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .stat {
            text-align: center;
            flex: 1;
            position: relative;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin: 0 5px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stat-value {
            font-size: 2.2rem;
            font-weight: bold;
            line-height: 1;
            margin-bottom: 5px;
            position: relative;
        }

        .stat-label {
            font-size: 0.8rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Enhanced energy container styling */
        .energy-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 15px 10px;
            margin-top: 15px;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3) inset;
            transition: all 0.3s ease;
        }

        .energy-slots {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
            min-height: 40px;
        }

        .energy-slot {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.15);
            position: relative;
            transition: all 0.4s ease;
            will-change: transform, opacity;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4);
        }

        .energy-slot.has-core {
            border-color: var(--tertiary-color);
            box-shadow: 0 0 15px rgba(255, 200, 87, 0.6);
            background: rgba(255, 200, 87, 0.25);
            transform: scale(1.1);
        }

        .energy-slot.has-core::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--tertiary-color), #e9b849);
            box-shadow: 0 0 8px rgba(255, 200, 87, 0.8);
            z-index: 1;
        }

        .energy-slot.has-core::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: white;
            z-index: 2;
        }

        .player1 .energy-slot.has-core::before {
            background: var(--player1-color);
        }

        .player2 .energy-slot.has-core::before {
            background: var(--player2-color);
        }

        .energy-count {
            position: absolute;
            bottom: -16px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            color: var(--text-color);
            opacity: 0.9;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.3);
            padding: 1px 8px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 0.5px;
        }

        /* Media queries with more specific selectors to avoid conflicts */
        @media (max-width: 1200px) {
            .game-content .player-cards {
                width: 220px;
                min-width: 220px;
            }
            
            .player-cards .player-card {
                min-height: 170px;
                padding: 15px;
            }
        }

        @media (max-width: 768px) {
            .game-content {
                flex-direction: column;
                align-items: center;
            }
            
            .game-content .player-cards {
                width: 100%;
                flex-direction: row;
                height: 180px;
                min-height: 180px;
                margin-bottom: 20px;
            }
            
            .player-cards .player-card {
                width: 48%;
                height: 100%;
                margin: 0 1%;
                min-height: unset;
            }
        }
        /* Player card glow effect when active */
        .player1.active {
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4), 
                        0 0 25px rgba(255, 90, 95, 0.2);
        }

        .player2.active {
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.4), 
                        0 0 25px rgba(62, 205, 193, 0.2);
        }

        /* Media queries adjustments */
        @media (max-width: 1200px) {
            .player-cards {
                width: 250px;
                min-width: 250px;
            }
            
            .player-card {
                min-height: 200px;
                padding: 20px;
            }
        }

        @media (max-width: 768px) {
            .player-cards {
                width: 100%;
                flex-direction: row;
                height: 220px; /* Increased from 200px */
                min-height: 220px;
                margin-bottom: 20px;
            }
            
            .player-card {
                width: 48%; /* Adjusted from 45% */
                height: 100%;
                margin: 0 1%;
                min-height: unset;
            }
        }

        /* Game board container - always maintain center alignment */
        .game-board-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto;
            position: relative;
            overflow: hidden; /* Prevent scrollbars during resize */
            /* Remove explicit flex sizing to allow container to match grid size */
        }

        /* Game board - enforce square aspect ratio */
        .game-board {
            width: 100%;
            height: 100%;
            border-radius: 15px;
            overflow: hidden;
            background-color: var(--grid-color);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.4), 
                        inset 0 0 20px rgba(0, 0, 0, 0.6);
            position: relative;
            aspect-ratio: 1/1; /* Enforce 1:1 aspect ratio */
        }

        /* Canvas should always maintain square proportions */
        #gameCanvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
            display: block; /* Remove any inline spacing */
        }

        /* Media queries for responsive layout while keeping the grid square */
        @media (max-width: 768px) {
            .game-content {
                flex-direction: column;
                align-items: center;
            }
            
            .player-cards {
                width: 100%;
                flex-direction: row;
                max-height: 200px;
                margin-bottom: 20px;
            }
            
            .game-board-container {
                width: 90vw; /* Use viewport width for mobile */
                height: auto;
                max-width: 90vw;
                margin: 0 auto;
            }
            
            .game-board {
                width: 100%;
                height: auto;
                aspect-ratio: 1/1;
            }
        }
        /* Game controls */
        .game-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2;
            gap: 15px;
        }

        .token-selection {
            display: flex;
            gap: 15px;
        }

        .token-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--tertiary-color);
            color: var(--tertiary-color);
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .token-btn:hover {
            background-color: rgba(255, 200, 87, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .token-btn.active {
            background-color: var(--tertiary-color);
            color: var(--background-color);
            box-shadow: 0 0 15px rgba(255, 200, 87, 0.5);
        }

        .token-btn::after {
            content: "";
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: -100%;
            background: linear-gradient(90deg, 
                rgba(255,255,255,0) 0%, 
                rgba(255,255,255,0.2) 50%, 
                rgba(255,255,255,0) 100%);
            transition: transform 0.5s ease;
        }

        .token-btn:hover::after {
            left: 100%;
            transition: 0.5s ease;
        }

        .end-turn-btn {
            background: linear-gradient(45deg, var(--primary-color), #d63d42);
            color: white;
            padding: 12px 36px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
            min-width: 150px;
        }

        .end-turn-btn:hover {
            background: linear-gradient(45deg, #FF7175, #c83639);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .end-turn-btn::after {
            content: "";
            position: absolute;
            width: 30px;
            height: 100%;
            top: 0;
            left: -100px;
            background: linear-gradient(
                90deg,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.4) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            animation: btnShine 3s infinite;
        }

        @keyframes btnShine {
            0% { left: -100px; }
            20% { left: 100%; }
            100% { left: 100%; }
        }

        /* Game info */
        .game-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            flex-wrap: wrap;
            gap: 10px;
        }

        .turn-info, .game-status {
            font-size: 1.1rem;
            font-weight: 300;
            flex: 1;
            min-width: 200px;
        }

        .game-info-buttons {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .help-btn, .end-turn-btn {
            background-color: var(--tertiary-color);
            color: var(--background-color);
            border: none;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
        }

        .help-btn:hover, .end-turn-btn:hover {
            background-color: #e9b849;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        .end-turn-btn {
            background: linear-gradient(45deg, var(--primary-color), #d63d42);
        }

        .end-turn-btn:hover {
            background: linear-gradient(45deg, #FF7175, #c83639);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal.visible {
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 1;
        }

        .modal-content {
            background: radial-gradient(circle at center, #3a4e56, #23353B);
            margin: 10% auto;
            padding: 30px;
            width: 80%;
            max-width: 600px;
            border-radius: 15px;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
            max-height: 80vh;
            overflow-y: auto;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-color);
        }

        .modal.visible .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .modal-close:hover {
            color: #fff;
        }

        .modal-title {
            margin-bottom: 20px;
            color: var(--tertiary-color);
            font-size: 1.8rem;
            border-bottom: 2px solid rgba(255, 200, 87, 0.3);
            padding-bottom: 10px;
        }

        .modal-body h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            color: var(--secondary-color);
        }

        .modal-body p, .modal-body li {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .modal-body ul, .modal-body ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        /* Responsive adjustments */
        @media (max-width: 1200px) {
            .game-container {
                height: 95vh;
            }
            
            .player-cards {
                width: 200px;
            }
        }

        @media (max-width: 768px) {
            .game-content {
                flex-direction: column;
                padding: 10px;
            }
            
            .player-cards {
                width: 100%;
                flex-direction: row;
                height: 200px;
                margin-bottom: 20px;
            }
            
            .player-card {
                width: 45%;
                height: 100%;
                margin: 0 2.5%;
            }
            
            .game-board-container {
                width: 100%;
                height: 400px;
            }
            
            .game-board {
                width: 100%;
                height: 100%;
                max-width: none;
                max-height: none;
            }
            
            .game-controls {
                display: none; /* Hide the old controls container */
            }
            
            .end-turn-btn {
                width: auto;
                margin-left: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>ENERGY GRID</h1>
            <p>A strategic battle of energy cores and fusion reactions</p>
        </div>
        
        <div class="game-content">
            <div class="player-cards">
                <!-- Player cards will be dynamically generated here -->
            </div>
            
            <div class="game-board-container">
                <div class="game-board">
                    <canvas id="gameCanvas"></canvas>
                </div>
            </div>
            
            <div class="game-controls">
                <!-- End turn button moved to game info -->
            </div>
        </div>
        
        <div class="game-info">
            <div class="turn-info">
                <p>Current Turn: <span id="currentPlayer">Player 1</span></p>
            </div>
            <div class="game-status">
                <p id="gameStatus">Game in progress...</p>
            </div>
            <div class="game-info-buttons">
                <button class="help-btn" id="helpBtn">How to Play</button>
                <button class="end-turn-btn" id="endTurnBtn">End Turn</button>
            </div>
        </div>
    </div>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <span class="modal-close" id="closeModal">&times;</span>
            <h2 class="modal-title">How to Play Energy Grid</h2>
            <div class="modal-body">
                <h3>Game Objective</h3>
                <p>Score the most points by creating fusions and eliminating opponent cores.</p>
                
                <h3>Turn Structure</h3>
                <ol>
                    <li>Your first placed core each turn is automatically an Energy Core</li>
                    <li>Any additional cores placed are Charged Cores (using your available supply)</li>
                    <li>Click "End Turn" to confirm placement</li>
                </ol>
                
                <h3>Placing Cores</h3>
                <p>Click on empty grid cells to select them for placement. Click again to deselect. Cores are placed at the end of your turn.</p>
                
                <h3>Core Interactions</h3>
                <p><strong>Fusion (Same Cores):</strong> When you place a core orthogonally adjacent (not diagonally) to your own cores, they fuse into a single core at the placement location. The value of the new core is the sum of the fused cores.</p>
                <p><strong>Elimination (Different Cores):</strong> When you place a core orthogonally adjacent to opponent cores of equal or lesser value, the opponent's cores are eliminated and returned to their owner as charged cores.</p>
                
                <h3>Scoring</h3>
                <ul>
                    <li>Score increases by the sum of eliminated cores' values.</li>
                </ul>
                
                <h3>Charged Cores</h3>
                <ul>
                    <li>Players start with 0 charged cores.</li>
                    <li>Placing a charged core decreases your charged core count by 1.</li>
                    <li>When your cores are eliminated, they are returned to you as charged cores.</li>
                </ul>
                
                <h3>Game End</h3>
                <p>The game ends when a player reaches 20 points.</p>
            </div>
        </div>
    </div>
    
    <script>
        "use strict"; // Enable strict mode for better error detection
        
        console.log("Script loading");
    
        // Game constants
        const GRID_SIZE = 8;
        const PLAYER_COLORS = ['#FF5A5F', '#3ECDC1']; // Player 1, Player 2
        const PLAYER_GLOW = ['rgba(255, 90, 95, 0.7)', 'rgba(62, 205, 193, 0.7)']; // Player 1, Player 2 glow
        const PLAYER_NAMES = ['Player 1', 'Player 2'];
        const WINNING_SCORE = 20;

        // Game state
        let gameState = {
            currentPlayer: 0, // 0 or 1
            players: [
                { name: PLAYER_NAMES[0], score: 0, chargedCores: [], maxChargedCores: 5 }, // Changed to array
                { name: PLAYER_NAMES[1], score: 0, chargedCores: [], maxChargedCores: 5 }  // Changed to array
            ],
            grid: [], // Will be initialized as 2D array
            selectedCells: [], // Cells selected for token placement
            turnPhase: 'selecting', // 'selecting' or 'animation'
            placedEnergyToken: false, // Flag to track if energy token has been placed
            gameOver: false,
        };

        // Canvas and rendering variables
        let canvas, ctx;
        let cellSize;
        let animationFrameId;
        let animations = [];
        let particles = []; // For particle effects
        
        // Critical flag to prevent rendering before initialization is complete
        let gameReadyToRender = false;
        
        // Debug mode
        const DEBUG = false; // Changed to false to reduce logging
        
        function debug(message) {
            if (DEBUG) {
                console.log(message);
            }
        }
        
        // Global helper to directly update game status for critical messages
        function updateGameStatus(message, isError = false) {
            console.log(message);
            
            try {
                const statusElement = document.getElementById('gameStatus');
                if (statusElement) {
                    statusElement.textContent = message;
                    
                    if (isError) {
                        statusElement.style.color = 'red';
                        setTimeout(() => {
                            statusElement.style.color = ''; // Reset color after 3 seconds
                        }, 3000);
                    }
                }
            } catch (e) {
                console.error("Failed to update status:", e);
            }
        }
        
        // Initialize the grid with empty cells
        function initGrid() {
            debug("Initializing grid");
            gameState.grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                let row = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    row.push({
                        x,
                        y,
                        token: null, // null, 'energy-0', 'energy-1', 'charged-0', 'charged-1'
                        selected: false,
                        animation: null,
                        glow: 0 // For highlighting effects
                    });
                }
                gameState.grid.push(row);
            }
            debug(`Grid initialized with size ${GRID_SIZE}x${GRID_SIZE}`);
        }

        // Resize canvas to maintain a perfect square
        function resizeCanvas(shouldRender = true) {
            try {
                const gameContent = document.querySelector('.game-content');
                const boardContainer = canvas.parentElement.parentElement;
                
                // Get the available space in the game content area
                const availableWidth = gameContent.clientWidth - document.querySelector('.player-cards').offsetWidth - 40; // 40px for padding/margins
                const availableHeight = gameContent.clientHeight - 40; // 40px for padding
                
                // Always take the minimum dimension to ensure a perfect square
                const size = Math.min(availableWidth, availableHeight);
                
                // Set both dimensions to the same value to ensure a square
                canvas.width = size;
                canvas.height = size;
                
                // Update cellSize based on the new dimensions
                cellSize = size / GRID_SIZE;

                debug(`Canvas resized to ${size}x${size}, cell size: ${cellSize}`);
                
                // Apply CSS to ensure the canvas is visually square and the container matches
                canvas.style.width = `${size}px`;
                canvas.style.height = `${size}px`;
                
                // Also size the game board and container to match the canvas
                const gameBoard = canvas.parentElement;
                gameBoard.style.width = `${size}px`;
                gameBoard.style.height = `${size}px`;
                
                // Size the container to match the game board
                boardContainer.style.width = `${size}px`;
                boardContainer.style.height = `${size}px`;
                
                // Re-render after resize if shouldRender is true
                if (shouldRender) {
                    render();
                }
            } catch (error) {
                debug("Error resizing canvas: " + error.message);
                console.error(error);
            }
        }

        // Fix 2: Updated createPlayerCards function
        function createPlayerCards() {
            console.log("Creating player cards");
            
            const playerCardsContainer = document.querySelector('.player-cards');
            
            if (!playerCardsContainer) {
                console.error("Player cards container not found!");
                return;
            }
            
            // Clear existing content
            playerCardsContainer.innerHTML = '';
            
            console.log("Player cards container found, creating cards");
            
            gameState.players.forEach((player, index) => {
                const playerCard = document.createElement('div');
                playerCard.className = `player-card player${index + 1}`;
                if (index === gameState.currentPlayer) {
                    playerCard.classList.add('active');
                }
                
                playerCard.innerHTML = `
                    <h2 class="player-name">${player.name}</h2>
                    <div class="player-stats">
                        <div class="stat">
                            <div class="stat-value">${player.score}</div>
                            <div class="stat-label">Score</div>
                        </div>
                    </div>
                    <div class="energy-container">
                        <div class="energy-slots">
                            ${Array(player.maxChargedCores).fill('<div class="energy-slot"></div>').join('')}
                        </div>
                        <div class="energy-count">0/${player.maxChargedCores}</div>
                    </div>
                `;
                
                playerCardsContainer.appendChild(playerCard);
                console.log(`Player ${index + 1} card created with ${player.maxChargedCores} energy slots`);
            });
            
            // Initialize energy containers with a slight delay to ensure DOM is ready
            setTimeout(() => {
                gameState.players.forEach((player, index) => {
                    updateEnergyContainer(index);
                });
            }, 100);
        }


        // Fix 4: Enhanced updatePlayerCards function
        function updatePlayerCards() {
            console.log("Updating player cards");
            
            // Update each player card independently
            gameState.players.forEach((player, index) => {
                const playerCard = document.querySelector(`.player-card.player${index + 1}`);
                
                if (!playerCard) {
                    console.error(`Player ${index + 1} card not found!`);
                    return;
                }
                
                // Update score
                const scoreValue = playerCard.querySelector('.stat-value');
                if (scoreValue) {
                    scoreValue.textContent = player.score;
                }
                
                // Update active state
                if (index === gameState.currentPlayer) {
                    playerCard.classList.add('active');
                } else {
                    playerCard.classList.remove('active');
                }
                
                // Update energy container separately
                updateEnergyContainer(index);
            });
            
            // Update the current player indicator in the UI
            const currentPlayerElement = document.getElementById('currentPlayer');
            if (currentPlayerElement) {
                currentPlayerElement.textContent = gameState.players[gameState.currentPlayer].name;
            }
            
            const gameStatusElement = document.getElementById('gameStatus');
            if (gameStatusElement && gameState.turnPhase === 'selecting') {
                gameStatusElement.textContent = `${gameState.players[gameState.currentPlayer].name}'s turn`;
            }
        }

        // Fix 3: Improved updateEnergyContainer function
        function updateEnergyContainer(playerIndex) {
            const player = gameState.players[playerIndex];
            console.log(`Updating energy container for Player ${playerIndex + 1}`);
            console.log(`Current charged cores: ${player.chargedCores.length}/${player.maxChargedCores}`);
            
            const container = document.querySelector(`.player${playerIndex + 1} .energy-slots`);
            const countDisplay = document.querySelector(`.player${playerIndex + 1} .energy-count`);
            
            if (!container || !countDisplay) {
                console.error(`Could not find energy container elements for Player ${playerIndex + 1}`);
                return;
            }
            
            // Update slots - first ensure we have the correct number of slots
            if (container.children.length !== player.maxChargedCores) {
                container.innerHTML = Array(player.maxChargedCores).fill('<div class="energy-slot"></div>').join('');
            }
            
            // Now update each slot's appearance
            const slots = container.querySelectorAll('.energy-slot');
            
            // Clear all slots first
            slots.forEach(slot => {
                slot.classList.remove('has-core', 'full');
            });
            
            // Set the appropriate slots to active
            for (let i = 0; i < player.chargedCores.length && i < slots.length; i++) {
                slots[i].classList.add('has-core');
            }
            
            // Add 'full' state if needed
            if (player.chargedCores.length >= player.maxChargedCores) {
                slots.forEach(slot => {
                    if (slot.classList.contains('has-core')) {
                        slot.classList.add('full');
                    }
                });
            }
            
            // Update count display
            countDisplay.textContent = `${player.chargedCores.length}/${player.maxChargedCores}`;
            
            console.log(`Updated energy display for Player ${playerIndex + 1}`);
        }
        // Helper function to get click coordinates relative to canvas
        function getClickCoordinates(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const clickX = (event.clientX - rect.left) * scaleX;
            const clickY = (event.clientY - rect.top) * scaleY;
            
            return {
                x: Math.floor(clickX / cellSize),
                y: Math.floor(clickY / cellSize)
            };
        }

        // Helper function to check if coordinates are within grid bounds
        function isValidCell(x, y) {
            return x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE;
        }

        // Helper function to get cell at coordinates
        function getClickedCell(x, y) {
            if (!isValidCell(x, y)) return null;
            return gameState.grid[y][x];
        }

        // Helper function to count currently selected charged cores
        function getSelectedChargedCoreCount() {
            return gameState.selectedCells.filter(cell => cell.type === 'charged').length;
        }

        // Helper function to check if energy core has been placed this turn
        function hasPlacedEnergyCore() {
            return gameState.placedEnergyToken;
        }

        // Helper function to toggle cell selection
        function toggleCellSelection(cell, x, y) {
            if (cell.selected) {
                deselectCell(cell, x, y);
            } else if (!cell.token) {
                selectCell(cell, x, y);
            }
        }

        // Helper function to deselect a cell
        function deselectCell(cell, x, y) {
            const index = gameState.selectedCells.findIndex(
                selected => selected.x === x && selected.y === y
            );
            
            if (index !== -1) {
                const deselectedCell = gameState.selectedCells[index];
                
                if (deselectedCell.type === 'charged') {
                    gameState.players[gameState.currentPlayer].chargedCores.push(2);
                    updatePlayerCards();
                } else if (deselectedCell.type === 'energy') {
                    gameState.placedEnergyToken = false;
                }
                
                gameState.selectedCells.splice(index, 1);
            }
            
            cell.selected = false;
        }

        // Helper function to select a cell
        function selectCell(cell, x, y) {
            const tokenType = gameState.selectedCells.length === 0 ? 'energy' : 'charged';
            
            if (tokenType === 'charged') {
                if (!canPlaceChargedCore()) {
                    return false;
                }
                
                // Remove one charged core and update UI
                gameState.players[gameState.currentPlayer].chargedCores.pop();
                updatePlayerCards();
                updateGameStatus("Charged core selected");
            } else {
                if (!canPlaceEnergyCore()) {
                    return false;
                }
                
                gameState.placedEnergyToken = true;
                updateGameStatus("Energy core selected");
            }
            
            cell.selected = true;
            gameState.selectedCells.push({ x, y, type: tokenType });
            addSelectionParticles(x, y);
            return true;
        }

        // Helper function to check if a charged core can be placed
        function canPlaceChargedCore() {
            if (gameState.players[gameState.currentPlayer].chargedCores.length === 0) {
                updateGameStatus("No charged cores available!", true);
                setTimeout(() => updateGameStatus("Game in progress..."), 2000);
                return false;
            }
            
            //const usedChargedCores = getSelectedChargedCoreCount();
            if (0 == gameState.players[gameState.currentPlayer].chargedCores.length) {
                updateGameStatus("All available charged cores have been used!", true);
                setTimeout(() => updateGameStatus("Game in progress..."), 2000);
                return false;
            }
            
            return true;
        }

        // Helper function to check if an energy core can be placed
        function canPlaceEnergyCore() {
            if (!hasPlacedEnergyCore()) {
                return true;
            }
            
            updateGameStatus("You can only place one energy core per turn!", true);
            setTimeout(() => updateGameStatus("Game in progress..."), 2000);
            return false;
        }

        // Refactored handleCanvasClick function
        function handleCanvasClick(event) {
            if (!gameReadyToRender || gameState.turnPhase !== 'selecting' || gameState.gameOver) {
                updateGameStatus(gameState.gameOver ? "Game is over!" : "Cannot select during animations");
                return;
            }
            
            try {
                const { x, y } = getClickCoordinates(event);
                const cell = getClickedCell(x, y);
                
                if (!cell) {
                    updateGameStatus("Click outside grid bounds");
                    return;
                }
                
                if (cell.token) {
                    updateGameStatus("Cell already occupied");
                    return;
                }
                
                toggleCellSelection(cell, x, y);
                render();
                
            } catch (error) {
                console.error("Error handling grid click:", error);
                updateGameStatus("Error processing selection", true);
            }
        }

        // Add particles for selection feedback
        function addSelectionParticles(x, y) {
            const centerX = x * cellSize + cellSize / 2;
            const centerY = y * cellSize + cellSize / 2;
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                const lifespan = 30 + Math.random() * 20;
                
                particles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 2 + Math.random() * 3,
                    color: PLAYER_COLORS[gameState.currentPlayer],
                    alpha: 1,
                    life: lifespan,
                    maxLife: lifespan
                });
            }
        }

        // End the current turn
        function endTurn() {
            if (!gameReadyToRender || gameState.turnPhase !== 'selecting' || gameState.gameOver) {
                updateGameStatus(gameState.gameOver ? "Game is over!" : "Cannot end turn during animations");
                return;
            }
            
            if (!gameState.placedEnergyToken) {
                updateGameStatus("You must place one energy core!", true);
                setTimeout(() => updateGameStatus("Game in progress..."), 2000);
                return;
            }
            
            const chargedCount = gameState.selectedCells.filter(cell => cell.type === 'charged').length;
            
            try {
                gameState.turnPhase = 'animation';
                updateGameStatus("Processing turn...");
                
                placeTokens();
                gameState.placedEnergyToken = false;
                
                setTimeout(() => {
                    processCoreInteractions();
                }, 600);
            } catch (error) {
                console.error("Error ending turn:", error);
                gameState.turnPhase = 'selecting';
                updateGameStatus("Error processing turn", true);
            }
        }

        // Add constants for commonly used values
        const TOKEN_TYPES = {
            ENERGY: 'energy',
            CHARGED: 'charged'
        };

        const TOKEN_VALUES = {
            ENERGY: 1,
            CHARGED: 2
        };

        const ANIMATION_DURATIONS = {
            PLACEMENT: 40,
            FUSION: 50,
            ELIMINATION: 50,
            VICTORY_PULSE: 30,
            SCORE_UPDATE: 60
        };

        // Optimize token drawing with shared functions
        function drawTokenBase(x, y, radius, player, glow = 0) {
            // Shadow
            ctx.shadowColor = PLAYER_GLOW[player];
            ctx.shadowBlur = 10 + glow * 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Outer circle
            ctx.fillStyle = PLAYER_COLORS[player];
            ctx.beginPath();
            ctx.arc(x, y, radius * (1 + glow * 0.3), 0, Math.PI * 2);
            ctx.fill();
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Inner circle
            ctx.fillStyle = '#f5f5f5';
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.7 * (1 + glow * 0.1), 0, Math.PI * 2);
            ctx.fill();
            
            // Player indicator
            ctx.fillStyle = PLAYER_COLORS[player];
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.4 * (1 + glow * 0.2), 0, Math.PI * 2);
            ctx.fill();
            
            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x - radius * 0.2, y - radius * 0.2, radius * 0.15, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEnergyToken(x, y, radius, player, glow = 0) {
            drawTokenBase(x, y, radius, player, glow);
            
            // Add glow effect
            if (glow > 0) {
                const glowRadius = radius * (1.2 + glow * 0.5);
                const gradient = ctx.createRadialGradient(x, y, radius, x, y, glowRadius);
                gradient.addColorStop(0, PLAYER_GLOW[player]);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.globalAlpha = glow * 0.7;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, glowRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function drawChargedToken(x, y, radius, player, glow = 0) {
            // First draw outer glow
            const glowSize = glow * 20;
            const outerGradient = ctx.createRadialGradient(
                x, y, radius, 
                x, y, radius * 1.5 + glowSize
            );
            outerGradient.addColorStop(0, PLAYER_GLOW[player]);
            outerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.globalAlpha = 0.7 + glow * 0.3;
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(x, y, radius * 1.5 + glowSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
            
            // Draw base token
            drawTokenBase(x, y, radius, player, glow);
            
            // Energy ring
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = radius * 0.15;
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.7, 0, Math.PI * 2);
            ctx.stroke();
            
            // Lightning bolt
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = radius * 0.15;
            ctx.lineCap = 'round';
            
            ctx.beginPath();
            ctx.moveTo(x - radius * 0.3, y - radius * 0.4);
            ctx.lineTo(x, y - radius * 0.1);
            ctx.lineTo(x - radius * 0.2, y + radius * 0.4);
            ctx.stroke();
            
            // Add pulsating effect for charged cores
            if (glow === 0) {
                const pulseTime = Date.now() / 1000;
                const pulseFactor = (Math.sin(pulseTime * 3) + 1) * 0.5 * 0.3 + 0.7;
                
                const pulseGradient = ctx.createRadialGradient(
                    x, y, radius * 0.8 * pulseFactor,
                    x, y, radius * 1.3 * pulseFactor
                );
                pulseGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                pulseGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = pulseGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 1.3 * pulseFactor, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Update token placement to use constants
        function placeTokens() {
            try {
                console.log(`Placing ${gameState.selectedCells.length} tokens on the grid`);
                
                const placedPositions = [];
                
                gameState.selectedCells.forEach(selected => {
                    const { x, y, type } = selected;
                    
                    // Set token with initial value using constants
                    gameState.grid[y][x].token = `${type}-${gameState.currentPlayer}`;
                    gameState.grid[y][x].value = type === TOKEN_TYPES.ENERGY ? TOKEN_VALUES.ENERGY : TOKEN_VALUES.CHARGED;
                    gameState.grid[y][x].selected = false;
                    gameState.grid[y][x].justPlaced = true;
                    
                    placedPositions.push({ x, y });
                    
                    console.log(`Placed ${type} token at (${x}, ${y}) with value ${gameState.grid[y][x].value}`);
                    
                    // Add placement animation with constant duration
                    animations.push({
                        type: 'placement',
                        x,
                        y,
                        progress: 0,
                        duration: ANIMATION_DURATIONS.PLACEMENT,
                        tokenType: type,
                        player: gameState.currentPlayer
                    });
                });
                
                gameState.selectedCells = [];
            } catch (error) {
                console.error("Error placing tokens:", error);
            }
        }

        // Process core interactions (fusions and eliminations)
        function processCoreInteractions() {
            try {
                console.log("\n----- Processing Core Interactions -----");
                
                // Find all cells marked as just placed
                const newCores = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const cell = gameState.grid[y][x];
                        if (cell.token && cell.justPlaced) {
                            const value = cell.value || (cell.token.startsWith('charged') ? 2 : 1);
                            newCores.push({ x, y, value });
                            console.log(`New core placed at (${x}, ${y}) with value ${value}`);
                        }
                    }
                }
                
                console.log(`Found ${newCores.length} newly placed cores to check for interactions`);
                
                // First handle eliminations - any opponent core adjacent to newly placed cores
                const eliminations = [];
                const eliminatedPositions = new Set(); // Track positions to avoid duplicates
                
                newCores.forEach(core => {
                    // Get the value of this newly placed core
                    const placedCoreValue = core.value;
                    console.log(`Checking for eliminations from core at (${core.x}, ${core.y}) with value ${placedCoreValue}`);
                    
                    // Get adjacent cells
                    const adjacentCells = getAdjacentCells(core.x, core.y);
                    
                    // Check for opponent cores to eliminate (only equal or lesser value)
                    adjacentCells.forEach(adjInfo => {
                        const adjCell = adjInfo.cell;
                        if (!adjCell.token) return;
                        
                        const adjTokenParts = adjCell.token.split('-');
                        const adjPlayer = parseInt(adjTokenParts[1]);
                        const adjTokenType = adjTokenParts[0];
                        
                        // Calculate the value of the adjacent enemy core
                        const adjCoreValue = adjCell.value || (adjTokenType === 'energy' ? 1 : 2);
                        
                        console.log(`Checking elimination: Core at (${core.x}, ${core.y}) value ${placedCoreValue} vs adjacent at (${adjInfo.x}, ${adjInfo.y}) value ${adjCoreValue}`);
                        
                        // If adjacent core belongs to opponent AND has lower value
                        if (adjPlayer !== gameState.currentPlayer && placedCoreValue > adjCoreValue) {
                            const posKey = `${adjInfo.x},${adjInfo.y}`;
                            
                            // Skip if already processed
                            if (eliminatedPositions.has(posKey)) return;
                            eliminatedPositions.add(posKey);
                            
                            console.log(`Found eligible elimination at (${adjInfo.x}, ${adjInfo.y}): value ${adjCoreValue} < ${placedCoreValue}`);
                            
                            // Add to eliminations
                            eliminations.push({
                                x: adjInfo.x,
                                y: adjInfo.y,
                                token: adjCell.token,
                                tokenType: adjTokenParts[0],
                                player: adjPlayer,
                                eliminatedBy: gameState.currentPlayer,
                                value: adjCoreValue
                            });
                        } else if (adjPlayer !== gameState.currentPlayer) {
                            console.log(`Skipping elimination at (${adjInfo.x}, ${adjInfo.y}): value ${adjCoreValue} > ${placedCoreValue}`);
                        }
                    });
                });
                
                // Then handle fusions - for each newly placed core, find connected friendly cores
                const fusions = [];
                const processedForFusion = new Set(); // Track positions we've already processed
                
                newCores.forEach(newCore => {
                    const posKey = `${newCore.x},${newCore.y}`;
                    
                    // Skip if this core has already been included in a fusion
                    if (processedForFusion.has(posKey)) return;
                    
                    const cell = gameState.grid[newCore.y][newCore.x];
                    if (!cell.token) return; // Safety check
                    
                    const tokenParts = cell.token.split('-');
                    const player = parseInt(tokenParts[1]);
                    
                    // Check adjacent cells for same player cores
                    const adjacentCells = getAdjacentCells(newCore.x, newCore.y);
                    const sameCores = adjacentCells.filter(adjInfo => {
                        if (!adjInfo.cell.token) return false;
                        
                        const adjTokenParts = adjInfo.cell.token.split('-');
                        return parseInt(adjTokenParts[1]) === player;
                    });
                    
                    console.log(`Checking fusions for core at (${newCore.x}, ${newCore.y}) - Found ${sameCores.length} adjacent friendly cores`);
                    
                    // If we found adjacent cores of the same player, create a fusion
                    if (sameCores.length > 0) {
                        // Start BFS from this newly placed core to find all connected cores
                        const fusionCells = [];
                        const queue = [newCore]; // Start with newly placed core
                        const visited = new Set([posKey]);
                        
                        while (queue.length > 0) {
                            const current = queue.shift();
                            fusionCells.push(current);
                            processedForFusion.add(`${current.x},${current.y}`);
                            
                            // Check all adjacent cells
                            const adj = getAdjacentCells(current.x, current.y);
                            adj.forEach(adjInfo => {
                                const adjCell = adjInfo.cell;
                                const adjKey = `${adjInfo.x},${adjInfo.y}`;
                                
                                // If adjacent cell has a token of the same player and not visited
                                if (adjCell.token && !visited.has(adjKey)) {
                                    const adjTokenParts = adjCell.token.split('-');
                                    const adjPlayer = parseInt(adjTokenParts[1]);
                                    
                                    if (adjPlayer === player) {
                                        queue.push({ x: adjInfo.x, y: adjInfo.y });
                                        visited.add(adjKey);
                                    }
                                }
                            });
                        }
                        
                        console.log(`Found ${fusionCells.length} connected cores for fusion`);
                        
                        // If we found more than one cell (the newly placed one plus at least one existing)
                        if (fusionCells.length > 1) {
                            // Calculate total value
                            let totalValue = 0;
                            let hasChargedCore = false;
                            
                            fusionCells.forEach(cell => {
                                const cellData = gameState.grid[cell.y][cell.x];
                                const cellValue = cellData.value || 
                                          (cellData.token && cellData.token.startsWith('charged') ? 2 : 1);
                                totalValue += cellValue;
                                
                                // Check if any core is charged
                                if (cellData.token && cellData.token.startsWith('charged')) {
                                    hasChargedCore = true;
                                }
                            });
                            
                            console.log(`Creating fusion with total value ${totalValue}`);
                            
                            fusions.push({
                                cells: fusionCells,
                                player: player,
                                newValue: totalValue,
                                resultType: hasChargedCore ? 'charged' : 'energy',
                                // Explicitly set the newly placed core as the target for fusion
                                targetCell: newCore
                            });
                        }
                    }
                });
                
                console.log(`Found ${fusions.length} fusions and ${eliminations.length} eliminations`);
                
                // Now clear the justPlaced flags as we're done with the identification phase
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (gameState.grid[y][x].justPlaced) {
                            gameState.grid[y][x].justPlaced = false;
                        }
                    }
                }
                
                // Process all interactions
                if (fusions.length > 0) {
                    // Animate fusions
                    fusions.forEach(fusion => {
                        animations.push({
                            type: 'fusion',
                            cells: fusion.cells,
                            progress: 0,
                            duration: ANIMATION_DURATIONS.FUSION,
                            player: fusion.player,
                            newValue: fusion.newValue,
                            resultType: fusion.resultType,
                            targetCell: fusion.targetCell
                        });
                    });
                    
                    // Apply fusions after animation
                    setTimeout(() => {
                        applyFusions(fusions);
                        
                        // Check for eliminations by the newly created higher-value cores
                        const postFusionEliminations = [];
                        fusions.forEach(fusion => {
                            const targetCell = fusion.targetCell;
                            console.log(`Checking post-fusion eliminations for core at (${targetCell.x}, ${targetCell.y}) with value ${fusion.newValue}`);
                            
                            // Get adjacent cells to check for eliminations
                            const adjacentCells = getAdjacentCells(targetCell.x, targetCell.y);
                            adjacentCells.forEach(adjInfo => {
                                const adjCell = adjInfo.cell;
                                if (!adjCell.token) return;
                                
                                const adjTokenParts = adjCell.token.split('-');
                                const adjPlayer = parseInt(adjTokenParts[1]);
                                const adjTokenType = adjTokenParts[0];
                                const adjCoreValue = adjCell.value || (adjTokenType === 'energy' ? 1 : 2);
                                
                                console.log(`Checking post-fusion elimination: Core at (${targetCell.x}, ${targetCell.y}) value ${fusion.newValue} vs adjacent at (${adjInfo.x}, ${adjInfo.y}) value ${adjCoreValue}`);
                                
                                // If adjacent core belongs to opponent AND has lower value
                                if (adjPlayer !== fusion.player && fusion.newValue > adjCoreValue) {
                                    console.log(`Found post-fusion elimination at (${adjInfo.x}, ${adjInfo.y}): value ${adjCoreValue} < ${fusion.newValue}`);
                                    postFusionEliminations.push({
                                        x: adjInfo.x,
                                        y: adjInfo.y,
                                        token: adjCell.token,
                                        tokenType: adjTokenParts[0],
                                        player: adjPlayer,
                                        eliminatedBy: fusion.player,
                                        value: adjCoreValue
                                    });
                                }
                            });
                        });
                        
                        // Process any eliminations found after fusions
                        if (postFusionEliminations.length > 0) {
                            setTimeout(() => {
                                processEliminations(postFusionEliminations);
                            }, 500);
                        } else if (eliminations.length > 0) {
                            // Process original eliminations if any
                            setTimeout(() => {
                                processEliminations(eliminations);
                            }, 500);
                        } else {
                            setTimeout(() => {
                                finishTurn();
                            }, 300);
                        }
                    }, 600);
                } else if (eliminations.length > 0) {
                    // Process eliminations directly if no fusions
                    processEliminations(eliminations);
                } else {
                    // No interactions, end turn
                    finishTurn();
                }
            } catch (error) {
                console.error("Error processing core interactions:", error);
                gameState.turnPhase = 'selecting'; // Reset phase on error
                updateGameStatus("Error processing turn", true);
            }
        }

        // Apply fusion results
        function applyFusions(fusions) {
            try {
                console.log("\n----- Applying Fusions -----");
                if (fusions.length === 0) {
                    console.log("No fusions to apply");
                    return;
                }
                
                fusions.forEach(fusion => {
                    console.log(`Applying fusion: ${fusion.cells.length} cells with new value ${fusion.newValue}`);
                    
                    // Use the explicitly specified target cell for the fusion result
                    // This should be the newly placed core that triggered the fusion
                    const targetCell = fusion.targetCell;
                    console.log(`Using target cell for fusion at (${targetCell.x}, ${targetCell.y})`);
                    
                    // Update the target cell's token type and value
                    gameState.grid[targetCell.y][targetCell.x].token = `${fusion.resultType || 'energy'}-${fusion.player}`;
                    gameState.grid[targetCell.y][targetCell.x].value = fusion.newValue;
                    gameState.grid[targetCell.y][targetCell.x].glow = 1;
                    
                    console.log(`Fusion result at (${targetCell.x}, ${targetCell.y}): ${fusion.resultType || 'energy'} token with value ${fusion.newValue}`);
                    
                    // Remove other cells involved in the fusion
                    for (const cell of fusion.cells) {
                        if (cell.x !== targetCell.x || cell.y !== targetCell.y) {
                            console.log(`Removing fused token at (${cell.x}, ${cell.y})`);
                            gameState.grid[cell.y][cell.x].token = null;
                            gameState.grid[cell.y][cell.x].value = null;
                        }
                    }
                });
                
                // Update player cards
                updatePlayerCards();
                console.log("Fusions applied successfully");
            } catch (error) {
                console.error("Error applying fusions:", error);
            }
        }

        // Process eliminations
        function processEliminations(eliminations) {
            try {
                console.log("\n----- Processing Eliminations -----");
                console.log(`Processing ${eliminations.length} eliminations`);
                
                if (!eliminations || eliminations.length === 0) {
                    console.log("No eliminations to process");
                    finishTurn();
                    return;
                }

                eliminations.forEach(elim => {
                    console.log(`\nElimination at (${elim.x}, ${elim.y}):`);
                    console.log(`- Token: ${elim.token}`);
                    console.log(`- Value: ${elim.value}`);
                    console.log(`- Eliminated by Player ${elim.eliminatedBy + 1}`);
                    
                    // Add elimination animation
                    animations.push({
                        type: 'elimination',
                        target: { x: elim.x, y: elim.y },
                        token: elim.token,
                        attacker: elim.eliminatedBy,
                        defender: elim.player,
                        progress: 0,
                        duration: ANIMATION_DURATIONS.ELIMINATION
                    });
                });
                
                // Calculate total value of eliminated cores
                let totalEliminatedValue = 0;
                
                // Group eliminations by player to correctly update charged counts
                const eliminationsByPlayer = {};
                
                eliminations.forEach(elim => {
                    // Get the value of the core (energy=1, charged=2 or specified value)
                    const value = elim.value || (elim.tokenType === 'energy' ? 1 : 2);
                    totalEliminatedValue += value;
                    
                    // Track eliminations by player to update charged core counts
                    if (!eliminationsByPlayer[elim.player]) {
                        eliminationsByPlayer[elim.player] = 0;
                    }
                    eliminationsByPlayer[elim.player]++;
                    
                    console.log(`[DEBUG] Elimination: Player ${elim.player}'s ${elim.tokenType} core (value: ${value})`);
                    
                    // Remove token from the grid
                    gameState.grid[elim.y][elim.x].token = null;
                    gameState.grid[elim.y][elim.x].value = null;
                });
                
                console.log("[DEBUG] Eliminations by player:", eliminationsByPlayer);
                
                // Return the eliminated cores to their owners as charged cores
                for (const [playerId, count] of Object.entries(eliminationsByPlayer)) {
                    const playerIndex = parseInt(playerId);
                    
                    // Try to add each eliminated core to the container
                    for (let i = 0; i < count; i++) {
                        addChargedCore(playerIndex);
                    }
                }
                
                // Award points to current player
                if (totalEliminatedValue > 0) {
                    gameState.players[gameState.currentPlayer].score += totalEliminatedValue;
                    console.log(`[DEBUG] Player ${gameState.currentPlayer + 1} gains ${totalEliminatedValue} points`);
                    
                    animations.push({
                        type: 'score-update',
                        player: gameState.currentPlayer,
                        value: totalEliminatedValue,
                        progress: 0,
                        duration: ANIMATION_DURATIONS.SCORE_UPDATE
                    });
                }
                
                // Force re-render of player cards and energy containers
                console.log("[DEBUG] Final charged tokens - P1:", gameState.players[0].chargedCores.length, "P2:", gameState.players[1].chargedCores.length);
                updatePlayerCards();
                
                // Update energy containers for all players with a slight delay to ensure animations complete
                setTimeout(() => {
                    gameState.players.forEach((player, index) => {
                        updateEnergyContainer(index);
                    });
                    
                    // Process after animations
                    setTimeout(() => {
                        console.log("[DEBUG] Post-timeout charged tokens - P1:", gameState.players[0].chargedCores.length, "P2:", gameState.players[1].chargedCores.length);
                        // Force one final update of energy containers
                        gameState.players.forEach((player, index) => {
                            updateEnergyContainer(index);
                        });
                        finishTurn();
                    }, 600);
                }, 100);
            } catch (error) {
                console.error("Error processing eliminations:", error);
                finishTurn(); // Try to recover by finishing the turn
            }
        }

        // Helper function to get the value of a cell's core
        function getCellValue(x, y) {
            const token = gameState.grid[y][x].token;
            if (!token) return 0;
            const tokenParts = token.split('-');
            const type = tokenParts[0];
            return type === 'energy' ? 1 : 2; // Energy cores = 1, Charged = 2
        }

        // Helper function to get adjacent cells (only horizontal and vertical, no diagonals)
        function getAdjacentCells(x, y) {
            const adjacentCells = [];
            const directions = [
                { dx: 1, dy: 0 },   // right
                { dx: -1, dy: 0 },  // left
                { dx: 0, dy: 1 },   // down
                { dx: 0, dy: -1 }   // up
            ];

            directions.forEach(dir => {
                const nx = x + dir.dx;
                const ny = y + dir.dy;

                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    const cell = gameState.grid[ny][nx];
                    console.log(`Checking adjacent cell at (${nx}, ${ny}): ${cell.token || 'empty'}`);
                    adjacentCells.push({
                        cell: cell,
                        x: nx,
                        y: ny
                    });
                }
            });
            return adjacentCells;
        }

        // Check for eliminations
        function checkEliminations() {
            const eliminations = [];
            
            // Check for surrounded opponent tokens (horizontally, vertically, diagonally)
            const directions = [
                { dx: 1, dy: 0 },   // right
                { dx: -1, dy: 0 },  // left
                { dx: 0, dy: 1 },   // down
                { dx: 0, dy: -1 },  // up
                { dx: 1, dy: 1 },   // down-right
                { dx: -1, dy: -1 }, // up-left
                { dx: 1, dy: -1 },  // up-right
                { dx: -1, dy: 1 }   // down-left
            ];
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = gameState.grid[y][x];
                    if (!cell.token) continue;
                    
                    // Get player from token
                    const tokenParts = cell.token.split('-');
                    const tokenType = tokenParts[0];
                    const defender = parseInt(tokenParts[1]);
                    
                    // For each possible attacker
                    for (let attacker = 0; attacker < 2; attacker++) {
                        // Skip if checking against own tokens
                        if (attacker === defender) continue;
                        
                        // Count surrounding attacker tokens
                        let surroundCount = 0;
                        
                        directions.forEach(dir => {
                            const nx = x + dir.dx;
                            const ny = y + dir.dy;
                            
                            if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                                const neighborCell = gameState.grid[ny][nx];
                                if (neighborCell.token) {
                                    const neighborTokenParts = neighborCell.token.split('-');
                                    const neighborPlayer = parseInt(neighborTokenParts[1]);
                                    
                                    if (neighborPlayer === attacker) {
                                        surroundCount++;
                                    }
                                }
                            }
                        });
                        
                        // If surrounded by at least 3 attacker tokens, mark for elimination
                        if (surroundCount >= 3) {
                            eliminations.push({
                                x,
                                y,
                                token: cell.token,
                                tokenType,
                                attacker,
                                defender
                            });
                            break; // Only one attacker can eliminate this token
                        }
                    }
                }
            }
            
            return eliminations;
        }

        // Apply eliminations
        function applyEliminations(eliminations) {
            eliminations.forEach(elim => {
                // Remove token
                gameState.grid[elim.y][elim.x].token = null;
                
                // Award points to attacker
                const tokenParts = elim.token.split('-');
                const tokenType = tokenParts[0];
                
                // 1 point for energy token, 3 for charged
                const points = tokenType === 'energy' ? 1 : 3;
                gameState.players[elim.attacker].score += points;
            });
            
            // Update player cards
            updatePlayerCards();
        }

        // Finish the current turn
        function finishTurn() {
            console.log("\n----- Turn Complete -----");
            logBoardState("Final ");
            console.log(`Charged tokens - P1: ${gameState.players[0].chargedCores.length}, P2: ${gameState.players[1].chargedCores.length}`);
            console.log(`Scores - P1: ${gameState.players[0].score}, P2: ${gameState.players[1].score}`);
            console.log("========== TURN END ==========\n");
            
            // Check for game end condition
            if (checkGameEnd()) return;
            
            // Switch to next player
            gameState.currentPlayer = 1 - gameState.currentPlayer;
            
            // Reset turn phase
            gameState.turnPhase = 'selecting';
            
            // Reset energy token placement flag for next turn
            gameState.placedEnergyToken = false;
            
            // Update UI
            updatePlayerCards();
            document.getElementById('gameStatus').textContent = `${gameState.players[gameState.currentPlayer].name}'s turn`;
        }

        // Check if the game has ended
        function checkGameEnd() {
            const winner = gameState.players[0].score >= WINNING_SCORE ? 0 : 
                          gameState.players[1].score >= WINNING_SCORE ? 1 : -1;
                          
            if (winner >= 0) {
                gameState.gameOver = true;
                document.getElementById('gameStatus').textContent = `Game Over! ${gameState.players[winner].name} wins!`;
                
                // Disable further interactions
                gameState.turnPhase = 'gameover';
                
                // Add victory animation
                addVictoryAnimation(winner);
                return true;
            }
            return false;
        }

        // Add victory animation
        function addVictoryAnimation(winner) {
            // Add lots of particles in winner's color
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 4;
                const lifespan = 80 + Math.random() * 120;
                
                particles.push({
                    x,
                    y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 3 + Math.random() * 6,
                    color: PLAYER_COLORS[winner],
                    alpha: 1,
                    life: lifespan,
                    maxLife: lifespan
                });
            }
            
            // Add victory animation to all tokens of the winner
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = gameState.grid[y][x];
                    if (cell.token) {
                        const tokenParts = cell.token.split('-');
                        const player = parseInt(tokenParts[1]);
                        
                        if (player === winner) {
                            cell.glow = 1; // Start glowing
                            
                            // Add pulse animation
                            animations.push({
                                type: 'victory-pulse',
                                x,
                                y,
                                progress: 0,
                                duration: ANIMATION_DURATIONS.VICTORY_PULSE,
                                player: winner
                            });
                        }
                    }
                }
            }
        }

        // Show help modal
        function showHelpModal() {
            const modal = document.getElementById('helpModal');
            modal.classList.add('visible');
            setTimeout(() => {
                modal.querySelector('.modal-content').style.opacity = 1;
                modal.querySelector('.modal-content').style.transform = 'translateY(0)';
            }, 50);
        }

        // Hide help modal
        function hideHelpModal() {
            const modal = document.getElementById('helpModal');
            const content = modal.querySelector('.modal-content');
            content.style.opacity = 0;
            content.style.transform = 'translateY(20px)';
            setTimeout(() => {
                modal.classList.remove('visible');
            }, 300);
        }

        // Add a shared animation drawing function
        function drawAnimation(anim) {
            const progress = anim.progress / anim.duration;
            
            switch (anim.type) {
                case 'placement':
                    drawPlacementAnimation(anim);
                    break;
                case 'fusion':
                    drawFusionAnimation(anim);
                    break;
                case 'elimination':
                    drawEliminationAnimation(anim);
                    break;
                case 'victory-pulse':
                    drawVictoryPulseAnimation(anim);
                    break;
                case 'score-update':
                    drawScoreUpdateAnimation(anim);
                    break;
            }
        }

        // Optimize particle system with a pool
        const particlePool = [];
        const MAX_PARTICLES = 500;

        function getParticle() {
            return particlePool.pop() || {
                x: 0,
                y: 0,
                vx: 0,
                vy: 0,
                radius: 0,
                color: '',
                alpha: 1,
                life: 0,
                maxLife: 0
            };
        }

        function recycleParticle(particle) {
            if (particlePool.length < MAX_PARTICLES) {
                particlePool.push(particle);
            }
        }

        // Optimize particle creation
        function createParticles(x, y, count, color, options = {}) {
            const {
                speed = 1,
                radius = 2,
                life = 30,
                spread = Math.PI * 2
            } = options;
            
            for (let i = 0; i < count; i++) {
                const particle = getParticle();
                const angle = (i / count) * spread;
                
                particle.x = x;
                particle.y = y;
                particle.vx = Math.cos(angle) * speed;
                particle.vy = Math.sin(angle) * speed;
                particle.radius = radius + Math.random() * 2;
                particle.color = color;
                particle.alpha = 1;
                particle.life = life + Math.random() * 20;
                particle.maxLife = particle.life;
                
                particles.push(particle);
            }
        }

        // Optimize particle update
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                particle.alpha = particle.life / particle.maxLife;
                
                if (particle.life <= 0) {
                    particles.splice(i, 1);
                    recycleParticle(particle);
                }
            }
        }

        // Update the game loop to use the new particle system
        function update() {
            try {
                if (!gameReadyToRender) return;
                
                // Update animations
                animations = animations.filter(anim => {
                    anim.progress++;
                    return anim.progress < anim.duration;
                });
                
                // Update particles
                updateParticles();
                
                // Update cell glow
                if (gameState && gameState.grid) {
                    for (let y = 0; y < GRID_SIZE; y++) {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            const cell = gameState.grid[y][x];
                            if (cell && cell.glow > 0) {
                                cell.glow *= 0.98;
                                if (cell.glow < 0.01) cell.glow = 0;
                            }
                        }
                    }
                }
            } catch (error) {
                console.error("Update error:", error);
            }
        }

        // Update render to use the new animation drawing function
        function render() {
            try {
                if (!gameReadyToRender || !ctx) return;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawGridBackground();
                drawGrid();
                
                if (!gameState.grid || !gameState.grid.length) return;
                
                drawTokensAndSelections();
                
                // Draw animations using the shared function
                animations.forEach(drawAnimation);
                
                drawParticles();
            } catch (error) {
                console.error("Render error:", error);
            }
        }

        // Draw background pattern
        function drawGridBackground() {
            // Background gradient
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#2a3d45');
            gradient.addColorStop(1, '#253035');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw subtle grid pattern
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if ((x + y) % 2 === 0) {
                        ctx.fillRect(
                            x * cellSize,
                            y * cellSize,
                            cellSize,
                            cellSize
                        );
                    }
                }
            }
            
            // Add subtle glow to the grid edges
            const edgeGlow = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.width / 4, 
                canvas.width / 2, canvas.height / 2, canvas.width / 1.5
            );
            edgeGlow.addColorStop(0, 'rgba(255, 255, 255, 0)');
            edgeGlow.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
            ctx.fillStyle = edgeGlow;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Draw the grid
        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;
            
            // Draw horizontal lines
            for (let i = 0; i <= GRID_SIZE; i++) {
                const y = i * cellSize;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw vertical lines
            for (let i = 0; i <= GRID_SIZE; i++) {
                const x = i * cellSize;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        // Draw tokens and selected cells
        function drawTokensAndSelections() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = gameState.grid[y][x];
                    const centerX = x * cellSize + cellSize / 2;
                    const centerY = y * cellSize + cellSize / 2;
                    const radius = cellSize * 0.4;
                    
                    // Draw selection
                    if (cell.selected) {
                        // Highlight background
                        const grd = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, cellSize * 0.6
                        );
                        grd.addColorStop(0, PLAYER_GLOW[gameState.currentPlayer]);
                        grd.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        
                        ctx.fillStyle = grd;
                        ctx.fillRect(
                            x * cellSize,
                            y * cellSize,
                            cellSize,
                            cellSize
                        );
                        
                        // Draw border
                        ctx.strokeStyle = PLAYER_COLORS[gameState.currentPlayer];
                        ctx.lineWidth = 2;
                        ctx.strokeRect(
                            x * cellSize + 2,
                            y * cellSize + 2,
                            cellSize - 4,
                            cellSize - 4
                        );
                        
                        // Draw token preview
                        ctx.globalAlpha = 0.7;
                        drawEnergyToken(centerX, centerY, radius, gameState.currentPlayer);
                        ctx.globalAlpha = 1.0;
                    }
                    
                    // Draw token
                    if (cell.token) {
                        const tokenParts = cell.token.split('-');
                        const tokenType = tokenParts[0];
                        const player = parseInt(tokenParts[1]);
                        
                        if (tokenType === 'energy') {
                            drawEnergyToken(centerX, centerY, radius, player, cell.glow);
                        } else {
                            drawChargedToken(centerX, centerY, radius, player, cell.glow);
                        }
                        
                        // Draw token value (if defined)
                        if (cell.value && cell.value > 1) {
                            // Add a background for better visibility
                            ctx.fillStyle = 'rgba(0,0,0,0.6)';
                            ctx.beginPath();
                            ctx.arc(centerX + radius * 0.6, centerY - radius * 0.6, radius * 0.3, 0, Math.PI * 2);
                            ctx.fill();
                            
                            // Draw the value
                            ctx.font = `bold ${Math.floor(radius * 0.5)}px Arial`;
                            ctx.fillStyle = 'white';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText(cell.value, centerX + radius * 0.6, centerY - radius * 0.6);
                        }
                    }
                }
            }
        }

        // Draw placement animation
        function drawPlacementAnimation(anim) {
            const centerX = anim.x * cellSize + cellSize / 2;
            const centerY = anim.y * cellSize + cellSize / 2;
            const progress = anim.progress / anim.duration;
            
            // Scale up from 0 to full size
            const radius = cellSize * 0.4 * Math.min(1, progress * 1.5);
            
            // Glow effect
            const glowSize = cellSize * 0.6 * (1 - Math.min(1, progress * 2));
            if (glowSize > 0) {
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, radius, 
                    centerX, centerY, radius + glowSize
                );
                gradient.addColorStop(0, PLAYER_GLOW[anim.player]);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.globalAlpha = 0.7 * (1 - progress);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius + glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
            
            // Ripple effect
            if (progress < 0.5) {
                const rippleSize = cellSize * progress * 2;
                ctx.strokeStyle = PLAYER_COLORS[anim.player];
                ctx.lineWidth = 2 * (1 - progress * 2);
                ctx.beginPath();
                ctx.arc(centerX, centerY, rippleSize, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Draw the token
            if (anim.tokenType === 'energy') {
                drawEnergyToken(centerX, centerY, radius, anim.player);
            } else {
                drawChargedToken(centerX, centerY, radius, anim.player);
            }
        }

        // Draw fusion animation
        function drawFusionAnimation(anim) {
            const progress = anim.progress / anim.duration;
            
            // Calculate center of the fusion
            let centerX = 0, centerY = 0;
            anim.cells.forEach(cell => {
                centerX += cell.x * cellSize + cellSize / 2;
                centerY += cell.y * cellSize + cellSize / 2;
            });
            centerX = centerX / anim.cells.length;
            centerY = centerY / anim.cells.length;
            
            // First half: converge to center
            if (progress < 0.5) {
                const fadeIn = Math.min(1, progress * 4);
                
                // Draw connecting energy lines
                ctx.strokeStyle = PLAYER_COLORS[anim.player];
                ctx.lineWidth = cellSize * 0.1 * fadeIn;
                ctx.shadowColor = PLAYER_GLOW[anim.player];
                ctx.shadowBlur = 15;
                
                anim.cells.forEach(cell => {
                    const cellCenterX = cell.x * cellSize + cellSize / 2;
                    const cellCenterY = cell.y * cellSize + cellSize / 2;
                    
                    // Calculate progress along line
                    const lineX = cellCenterX + (centerX - cellCenterX) * (progress * 2);
                    const lineY = cellCenterY + (centerY - cellCenterY) * (progress * 2);
                    
                    // Draw energy line
                    ctx.beginPath();
                    ctx.moveTo(cellCenterX, cellCenterY);
                    ctx.lineTo(lineX, lineY);
                    ctx.stroke();
                    
                    // Draw energy particles along the line
                    const particleCount = 3;
                    for (let i = 0; i < particleCount; i++) {
                        const t = (progress * 2) * (i / particleCount);
                        const px = cellCenterX + (centerX - cellCenterX) * t;
                        const py = cellCenterY + (centerY - cellCenterY) * t;
                        
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.beginPath();
                        ctx.arc(px, py, cellSize * 0.05, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            } else {
                // Second half: explosion
                const explosionProgress = (progress - 0.5) * 2;
                
                // Draw explosion
                const explosionRadius = cellSize * 1.5 * explosionProgress;
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, explosionRadius
                );
                gradient.addColorStop(0, PLAYER_COLORS[anim.player]);
                gradient.addColorStop(0.7, PLAYER_GLOW[anim.player]);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.globalAlpha = 1 - explosionProgress;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, explosionRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
                
                // Add particles
                if (anim.progress % 3 === 0) {
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = explosionRadius * 0.7;
                        const px = centerX + Math.cos(angle) * distance;
                        const py = centerY + Math.sin(angle) * distance;
                        
                        particles.push({
                            x: px,
                            y: py,
                            vx: Math.cos(angle) * (1 + Math.random() * 2),
                            vy: Math.sin(angle) * (1 + Math.random() * 2),
                            radius: 2 + Math.random() * 4,
                            color: PLAYER_COLORS[anim.player],
                            alpha: 1,
                            life: 20 + Math.random() * 10,
                            maxLife: 30
                        });
                    }
                }
                
                // Draw new core value at the end
                if (explosionProgress > 0.7) {
                    const valueProgress = (explosionProgress - 0.7) / 0.3;
                    
                    ctx.font = `bold ${Math.floor(cellSize * 0.5 * valueProgress)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = 'white';
                    ctx.fillText(anim.newValue || "", centerX, centerY);
                }
            }
        }

        // Draw elimination animation
        function drawEliminationAnimation(anim) {
            const progress = anim.progress / anim.duration;
            const centerX = anim.target.x * cellSize + cellSize / 2;
            const centerY = anim.target.y * cellSize + cellSize / 2;
            
            try {
                // First part: attacker energy effect
                if (progress < 0.7) {
                    const beamProgress = progress / 0.7;
                    
                    ctx.shadowColor = PLAYER_COLORS[anim.attacker];
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = PLAYER_COLORS[anim.attacker];
                    ctx.lineWidth = cellSize * 0.08 * (1 - Math.abs(beamProgress - 0.5) * 2);
                    
                    // Find all adjacent attacker cores
                    const attackerCores = [];
                    
                    // Get adjacent cells to the target
                    const adjacentDirections = [
                        { dx: 1, dy: 0 },   // right
                        { dx: -1, dy: 0 },  // left
                        { dx: 0, dy: 1 },   // down
                        { dx: 0, dy: -1 }   // up
                    ];
                    
                    // Check each adjacent cell for attacker cores
                    adjacentDirections.forEach(dir => {
                        const nx = anim.target.x + dir.dx;
                        const ny = anim.target.y + dir.dy;
                        
                        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                            const adjCell = gameState.grid[ny][nx];
                            if (adjCell.token) {
                                const tokenParts = adjCell.token.split('-');
                                const tokenPlayer = parseInt(tokenParts[1]);
                                
                                if (tokenPlayer === anim.attacker) {
                                    attackerCores.push({ x: nx, y: ny });
                                }
                            }
                        }
                    });
                    
                    // Draw beams from attacker cores to the target
                    attackerCores.forEach(attacker => {
                        const attackerX = attacker.x * cellSize + cellSize / 2;
                        const attackerY = attacker.y * cellSize + cellSize / 2;
                        
                        // Draw beam
                        ctx.beginPath();
                        ctx.moveTo(attackerX, attackerY);
                        ctx.lineTo(centerX, centerY);
                        ctx.stroke();
                        
                        // Draw energy particles along the beam
                        const particleCount = 4;
                        for (let i = 0; i < particleCount; i++) {
                            // Oscillate particle position
                            const oscillation = Math.sin((beamProgress * 10) + (i / particleCount * Math.PI * 2));
                            const t = beamProgress * (i / particleCount) + oscillation * 0.05;
                            const px = attackerX + (centerX - attackerX) * t;
                            const py = attackerY + (centerY - attackerY) * t;
                            
                            ctx.fillStyle = 'white';
                            ctx.beginPath();
                            ctx.arc(px, py, cellSize * 0.04, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });
                    
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    
                    // Draw target token with increasing glow/shake
                    const tokenParts = anim.token.split('-');
                    const tokenType = tokenParts[0];
                    const player = parseInt(tokenParts[1]);
                    
                    // Calculate shake offset
                    const shakeAmount = beamProgress * 3;
                    const offsetX = (Math.random() * 2 - 1) * shakeAmount;
                    const offsetY = (Math.random() * 2 - 1) * shakeAmount;
                    
                    // Draw with increasing glow
                    if (tokenType === 'energy') {
                        drawEnergyToken(centerX + offsetX, centerY + offsetY, cellSize * 0.4, player, beamProgress);
                    } else {
                        drawChargedToken(centerX + offsetX, centerY + offsetY, cellSize * 0.4, player, beamProgress);
                    }
                } else {
                    // Explosion effect for the elimination
                    const explosionProgress = (progress - 0.7) / 0.3;
                    
                    // Draw explosion
                    const explosionRadius = cellSize * explosionProgress;
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, explosionRadius
                    );
                    gradient.addColorStop(0, 'white');
                    gradient.addColorStop(0.3, PLAYER_COLORS[anim.attacker]);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    
                    ctx.globalAlpha = 1 - explosionProgress * 0.5;
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, explosionRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    
                    // Create explosion particles
                    if (anim.progress % 2 === 0 && explosionProgress < 0.5) {
                        for (let i = 0; i < 3; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = 1 + Math.random() * 3;
                            
                            particles.push({
                                x: centerX,
                                y: centerY,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                radius: 3 + Math.random() * 4,
                                color: PLAYER_COLORS[anim.defender], // Use defender's color for the particles
                                alpha: 1,
                                life: 20 + Math.random() * 10,
                                maxLife: 30
                            });
                        }
                    }
                    
                    // Draw "Returned" indicator at the end
                    if (explosionProgress > 0.6) {
                        const textProgress = (explosionProgress - 0.6) / 0.4;
                        
                        ctx.font = `bold ${Math.floor(cellSize * 0.3 * textProgress)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = PLAYER_COLORS[anim.defender];
                        ctx.fillText("Returned", centerX, centerY - cellSize * 0.3 * textProgress);
                    }
                }
            } catch (error) {
                console.error("Error drawing elimination animation:", error);
            }
        }

        // Draw victory pulse animation for winner's tokens
        function drawVictoryPulseAnimation(anim) {
            const progress = anim.progress / anim.duration;
            const x = anim.x * cellSize + cellSize / 2;
            const y = anim.y * cellSize + cellSize / 2;
            
            // Pulse glow around the token
            const pulseSize = cellSize * 0.6 * Math.sin(progress * Math.PI);
            
            const gradient = ctx.createRadialGradient(
                x, y, cellSize * 0.4,
                x, y, cellSize * 0.4 + pulseSize
            );
            gradient.addColorStop(0, PLAYER_GLOW[anim.player]);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.globalAlpha = 0.7 * (1 - progress);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, cellSize * 0.4 + pulseSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
            
            // Add particles at peak
            if (progress > 0.45 && progress < 0.55 && anim.progress % 3 === 0) {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = cellSize * 0.5;
                    
                    particles.push({
                        x: x + Math.cos(angle) * distance,
                        y: y + Math.sin(angle) * distance,
                        vx: Math.cos(angle) * 1,
                        vy: Math.sin(angle) * 1,
                        radius: 2 + Math.random() * 2,
                        color: PLAYER_COLORS[anim.player],
                        alpha: 0.7,
                        life: 15 + Math.random() * 10,
                        maxLife: 25
                    });
                }
            }
            
            // Update cell glow for victory effect
            if (progress > 0.8) {
                gameState.grid[anim.y][anim.x].glow = 0.8;
            }
        }

        // Draw score update animation
        function drawScoreUpdateAnimation(anim) {
            const progress = anim.progress / anim.duration;
            const playerCard = document.querySelector(`.player${anim.player + 1}`);
            
            if (!playerCard) return;
            
            const rect = playerCard.getBoundingClientRect();
            const canvasRect = canvas.getBoundingClientRect();
            
            // Calculate position relative to canvas
            const x = rect.left - canvasRect.left + rect.width / 2;
            const y = rect.top - canvasRect.top + rect.height / 2;
            
            // Draw floating score text
            const fontSize = 24 + progress * 12; // Grow from 24px to 36px
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Add glow effect
            ctx.shadowColor = PLAYER_COLORS[anim.player];
            ctx.shadowBlur = 10;
            
            // Draw the score value
            ctx.fillStyle = 'white';
            ctx.fillText(`+${anim.value}`, x, y - progress * 30); // Float up
            
            // Add particles
            if (anim.progress % 3 === 0) {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1 + Math.random() * 2;
                    
                    particles.push({
                        x: x,
                        y: y - progress * 30,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 1, // Slight upward bias
                        radius: 2 + Math.random() * 3,
                        color: PLAYER_COLORS[anim.player],
                        alpha: 1 - progress,
                        life: 20 + Math.random() * 10,
                        maxLife: 30
                    });
                }
            }
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        // Draw particles
        function drawParticles() {
            try {
                particles.forEach(particle => {
                    ctx.globalAlpha = particle.alpha;
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1.0;
            } catch (error) {
                console.error("Error drawing particles:", error);
            }
        }

        // Game loop function to handle animations and rendering
        function gameLoop() {
            try {
                if (!gameReadyToRender) {
                    requestAnimationFrame(gameLoop);
                    return;
                }
                
                // Update game state
                update();
                
                // Render the game
                render();
                
                // Request next frame
                requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error("Game loop error:", error);
                // Try to recover by continuing the loop
                requestAnimationFrame(gameLoop);
            }
        }

        // Initialize game when DOM is fully loaded
        function init() {
            console.log("Starting initialization...");
            
            try {
                // Safety check - don't initialize multiple times
                if (window.gameInitialized) {
                    console.log("Game already initialized, skipping");
                    return;
                }
                
                window.gameInitialized = true;
                console.log("Game initialization flag set");
                
                // Initialize grid first to ensure it's ready
                initGrid();
                console.log("Grid initialized FIRST in the sequence");
                
                // Get canvas explicitly
                canvas = document.getElementById('gameCanvas');
                
                if (!canvas) {
                    console.error("Could not find the gameCanvas element!");
                    alert("Error: Could not find the game canvas. Please refresh the page.");
                    return;
                }
                
                // Get context
                ctx = canvas.getContext('2d');
                
                if (!ctx) {
                    console.error("Could not get 2D context from canvas!");
                    alert("Error: Could not initialize the game canvas. Please try a different browser.");
                    return;
                }
                
                console.log("Canvas and context obtained successfully");
                
                // Set up player cards first before any rendering
                createPlayerCards();
                console.log("Player cards created successfully");
                
                // Resize canvas (but don't render yet)
                resizeCanvas(false);
                console.log("Canvas resized without rendering");
                
                // Set up all event listeners directly
                setupEventListeners();
                
                // Now set the ready flag
                gameReadyToRender = true;
                console.log("Game ready to render flag set");
                
                // Start the game loop only when everything is ready
                gameLoop();
                
                console.log("Game initialization complete");
            } catch (error) {
                console.error("Initialization error:", error);
                alert("Game initialization failed. Please reload the page.");
            }
        }
        
        // Separate function to set up all event listeners
        function setupEventListeners() {
            try {
                // Add canvas click listener
                if (canvas) {
                    canvas.onclick = handleCanvasClick;
                    console.log("Canvas click listener attached");
                }
                
                // Setup End Turn button
                const endTurnBtn = document.getElementById('endTurnBtn');
                if (endTurnBtn) {
                    endTurnBtn.onclick = function() {
                        console.log("End turn button clicked");
                        endTurn();
                    };
                    console.log("End turn button listener attached");
                }
                
                // Help button
                const helpBtn = document.getElementById('helpBtn');
                if (helpBtn) {
                    helpBtn.onclick = function() {
                        console.log("Help button clicked");
                        showHelpModal();
                    };
                    console.log("Help button listener attached");
                }
                
                // Close modal button
                const closeModalBtn = document.getElementById('closeModal');
                if (closeModalBtn) {
                    closeModalBtn.onclick = function() {
                        console.log("Close modal button clicked");
                        hideHelpModal();
                    };
                    console.log("Close modal button listener attached");
                }
                
                // Window resize listener
                window.addEventListener('resize', resizeCanvas);
                
                console.log("All event listeners attached successfully");
            } catch (error) {
                console.error("Error setting up event listeners:", error);
            }
        }
                
        // Use both initialization methods with window.onload as primary for full reliability
        window.onload = init;

        // Helper function to log board state
        function logBoardState(prefix = "") {
            console.log(`\n${prefix}Board State:`);
            for (let y = 0; y < GRID_SIZE; y++) {
                let row = "";
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = gameState.grid[y][x];
                    if (!cell.token) {
                        row += "[ ] ";
                    } else {
                        const tokenParts = cell.token.split('-');
                        const type = tokenParts[0][0].toUpperCase(); // E for energy, C for charged
                        const player = parseInt(tokenParts[1]) + 1;  // Convert to 1-based for readability
                        const value = cell.value || (type === 'E' ? 1 : 2);
                        row += `[${type}${player}:${value}] `;
                    }
                }
                console.log(row);
            }
            console.log("\n");
        }

        // Fix 5: Improved addChargedCore function
        function addChargedCore(playerIndex, coreValue = 2) {
            const player = gameState.players[playerIndex];
            
            // Check if we can add more cores
            if (player.chargedCores.length >= player.maxChargedCores) {
                console.log(`Player ${playerIndex + 1}'s energy container is full`);
                return false;
            }
            
            // Add the core to the player's supply
            player.chargedCores.push(coreValue);
            console.log(`Added charged core to Player ${playerIndex + 1} (now has ${player.chargedCores.length})`);
            
            // Update the visual display
            updateEnergyContainer(playerIndex);
            return true;
        }

        function removeChargedCore(playerIndex) {
            const player = gameState.players[playerIndex];
            if (player.chargedCores.length === 0) {
                console.log(`[DEBUG] Player ${playerIndex + 1}'s energy container is empty`);
                return null;
            }
            
            const core = player.chargedCores.pop();
            updateEnergyContainer(playerIndex);
            return core;
        }

        function updateEnergyContainer(playerIndex) {
            const player = gameState.players[playerIndex];
            console.log(`[DEBUG] Updating energy container for Player ${playerIndex + 1}`);
            console.log(`[DEBUG] Current charged cores: ${player.chargedCores.length}/${player.maxChargedCores}`);
            
            const container = document.querySelector(`.player${playerIndex + 1} .energy-slots`);
            const countDisplay = document.querySelector(`.player${playerIndex + 1} .energy-count`);
            
            if (!container || !countDisplay) {
                console.error(`[DEBUG] Could not find energy container elements for Player ${playerIndex + 1}`);
                return;
            }
            
            // Update slots
            const slots = container.querySelectorAll('.energy-slot');
            console.log(`[DEBUG] Found ${slots.length} energy slots`);
            
            // Remove all classes first to ensure clean state
            slots.forEach(slot => {
                slot.classList.remove('has-core', 'full');
            });
            
            // Now add classes based on current state
            slots.forEach((slot, index) => {
                if (index < player.chargedCores.length) {
                    slot.classList.add('has-core');
                    if (player.chargedCores.length >= player.maxChargedCores) {
                        slot.classList.add('full');
                    }
                    console.log(`[DEBUG] Slot ${index + 1}: Added core`);
                } else {
                    console.log(`[DEBUG] Slot ${index + 1}: Empty`);
                }
            });
            
            // Update count display
            countDisplay.textContent = `${player.chargedCores.length}/${player.maxChargedCores}`;
            console.log(`[DEBUG] Updated count display to ${player.chargedCores.length}/${player.maxChargedCores}`);
            
            // Force a reflow to ensure the changes are applied
            container.offsetHeight;
        }

    </script>
</body>
</html>
