<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Grid Game</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
        integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Mid-century modern inspired design with energy theme */
        :root {
            --primary-color: #FF5A5F;
            --secondary-color: #3ECDC1;
            --tertiary-color: #FFC857;
            --background-color: #2A3D45;
            --grid-color: #3F4E4F;
            --text-color: #EFF6E0;
            --player1-color: #FF5A5F;
            --player2-color: #3ECDC1;
            --player1-glow: rgba(255, 90, 95, 0.6);
            --player2-glow: rgba(62, 205, 193, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .game-container {
            max-width: 1200px;
            width: 100%;
            background: radial-gradient(circle at center, #3a4e56, #23353B);
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            position: relative;
        }

        .game-header {
            background: linear-gradient(135deg, var(--primary-color), #8a3236);
            padding: 5px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .game-header::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(45deg,
                    rgba(255, 255, 255, 0.05),
                    rgba(255, 255, 255, 0.05) 10px,
                    rgba(255, 255, 255, 0) 10px,
                    rgba(255, 255, 255, 0) 20px);
        }

        .game-header h1 {
            font-weight: 700;
            letter-spacing: 3px;
            font-size: 2.8rem;
            margin-bottom: 5px;
            position: relative;
            text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.2);
        }

        .game-header p {
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
            font-weight: 300;
        }

        .game-content {
            display: flex;
            flex-direction: column;
            padding: 25px;
            position: relative;
            z-index: 1;
        }

        /* Style for the countdown */
        .surge-countdown {
            font-size: 0.9rem;
            color: var(--tertiary-color);
            margin-left: 15px;
            /* Space it from the turn info */
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 200, 87, 0.5);
        }

        /* Style for the surge animation overlay (optional, if needed) */
        .surge-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, rgba(255, 255, 150, 0.6), rgba(62, 205, 193, 0.6), rgba(255, 90, 95, 0.6));
            mix-blend-mode: lighten;
            /* Or screen, overlay */
            pointer-events: none;
            opacity: 0;
            z-index: 50;
            /* Above cards, below modal */
            transition: opacity 0.3s ease-out;
        }

        .surge-overlay.active {
            opacity: 1;
            animation: surge-wipe 0.8s ease-in-out forwards;
        }

        @keyframes surge-wipe {
            0% {
                transform: translateY(-100%);
                opacity: 0;
            }

            30% {
                transform: translateY(0%);
                opacity: 0.7;
            }

            70% {
                transform: translateY(0%);
                opacity: 0.7;
            }

            100% {
                transform: translateY(100%);
                opacity: 0;
            }
        }

        /* Player cards */
        .player-cards {
            position: relative;
            /* Needed for z-index stacking */
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 5px;
            gap: 5px;
        }

        .charged-cores {
            display: flex;
            justify-content: center;
            margin-top: 10px;
        }

        /* Charged Core Icon Styling */
        .charged-core-icon {
            width: 22px;
            /* Slightly larger */
            height: 22px;
            margin: 0 4px;
            /* Adjust spacing */
            border-radius: 50%;
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.3), inset 0 0 4px rgba(0, 0, 0, 0.2);
            position: relative;
            /* Needed for positioning the value */
            display: inline-flex;
            /* Use flex to center value */
            justify-content: center;
            align-items: center;
            font-size: 10px;
            /* Base size for value */
            font-weight: bold;
            color: #1a252a;
            /* Dark contrast for value */
            text-shadow: 0px 0px 2px rgba(255, 255, 255, 0.5);
            /* Subtle highlight */
        }

        /* Value Display within the Core Icon */
        .charged-core-value {
            /* Value is now directly centered by the parent flex container */
            line-height: 1;
            /* Ensure tight vertical alignment */
        }

        .player-card {
            background: rgba(42, 61, 69, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 5px;
            width: 80%;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-card.active {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
        }

        .player-card.player1 {
            background: linear-gradient(45deg, rgba(68, 41, 41, 0.7), rgba(58, 35, 35, 0.7));
            border-left: 5px solid var(--player1-color);
        }

        .player-card.player2 {
            background: linear-gradient(45deg, rgba(34, 65, 63, 0.7), rgba(25, 53, 51, 0.7));
            border-left: 5px solid var(--secondary-color);
        }

        .player-card.active::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.1) 50%,
                    rgba(255, 255, 255, 0) 100%);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            0% {
                transform: translateX(-100%);
            }

            100% {
                transform: translateX(100%);
            }
        }

        .turn-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .player1.active.turn-indicator {
            background: radial-gradient(circle at center, var(--player1-color), #8a3236);
            box-shadow: 0 0 15px 5px var(--player1-glow);
            opacity: 1;
            animation: pulse 1.5s infinite;
        }

        .player2.active.turn-indicator {
            background: radial-gradient(circle at center, var(--secondary-color), #27918a);
            box-shadow: 0 0 15px 5px var(--player2-glow);
            opacity: 1;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(0.8);
                box-shadow: 0 0 15px 2px var(--player1-glow);
            }

            50% {
                transform: scale(1.2);
                box-shadow: 0 0 25px 5px var(--player1-glow);
            }

            100% {
                transform: scale(0.8);
                box-shadow: 0 0 15px 2px var(--player1-glow);
            }
        }

        .player-name {
            font-size: 1.6rem;
            margin-bottom: 20px;
            position: relative;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .player1.player-name {
            color: var(--player1-color);
            text-shadow: 0 0 10px rgba(255, 90, 95, 0.5);
        }

        .player2.player-name {
            color: var(--secondary-color);
            text-shadow: 0 0 10px rgba(62, 205, 193, 0.5);
        }

        .player-stats {
            display: flex;
            justify-content: space-between;
        }

        .stat {
            text-align: center;
            flex: 1;
            position: relative;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin: 0 5px;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            line-height: 1;
            margin-bottom: 8px;
            position: relative;
        }

        .player1.stat-value {
            color: var(--player1-color);
            text-shadow: 0 0 8px rgba(255, 90, 95, 0.5);
        }

        .player2.stat-value {
            color: var(--secondary-color);
            text-shadow: 0 0 8px rgba(62, 205, 193, 0.5);
        }

        .stat-label {
            font-size: 0.9rem;
            text-transform: uppercase;
            color: #CCC;
            letter-spacing: 1px;
            font-weight: 300;
        }

        /* Game board */
        .game-board-container {
            width: 100%;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            margin: 5px 0;
            position: relative;
        }

        .game-board {
            width: 100%;
            aspect-ratio: 1 / 1;
            border-radius: 15px;
            overflow: hidden;
            background-color: var(--grid-color);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.4),
                inset 0 0 20px rgba(0, 0, 0, 0.6);
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Game controls */
        .game-controls {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: right;
            margin-top: 30px;
        }

        .end-turn-btn {
            background: linear-gradient(45deg, var(--primary-color), #d63d42);
            color: white;
            padding: 12px 36px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .end-turn-btn:hover {
            background: linear-gradient(45deg, #FF7175, #c83639);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .end-turn-btn::after {
            content: "";
            position: absolute;
            width: 30px;
            height: 100%;
            top: 0;
            left: -100px;
            background: linear-gradient(90deg,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.4) 50%,
                    rgba(255, 255, 255, 0) 100%);
            animation: btnShine 3s infinite;
        }

        @keyframes btnShine {
            0% {
                left: -100px;
            }

            20% {
                left: 100%;
            }

            100% {
                left: 100%;
            }
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .setting-row label {
            font-weight: bold;
        }

        .setting-row input[type="number"] {
            width: 60px;
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
            text-align: center;
        }

        /* Game info */
        .game-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            /* Keep space between turn info and buttons */
            align-items: center;
        }

        .button-container {
            display: flex;
            gap: 10px;
            /* Space between buttons */
            align-items: center;
        }

        .turn-info,
        .game-status {
            font-size: 1.1rem;
            font-weight: 300;
        }

        /* General button style */
        .help-btn {
            background-color: var(--tertiary-color);
            color: var(--background-color);
            border: none;
            padding: 8px 12px;
            /* Reduced padding for icon buttons */
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            display: flex;
            /* Enable flexbox for icon alignment */
            align-items: center;
            /* Vertically center the icon */
            justify-content: center;
            /* Center icon horizontally */
            font-size: 1rem;
        }

        .help-btn:hover {
            background-color: #e9b849;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        /* Style for icon inside the button */
        .help-btn i {
            margin-right: 0;
            /* Remove text */
            font-size: 1.2rem;
            /* Adjust icon size */
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal.visible {
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 1;
        }

        .modal-content {
            background: radial-gradient(circle at center, #3a4e56, #23353B);
            margin: 10% auto;
            padding: 30px;
            width: 80%;
            max-width: 600px;
            border-radius: 15px;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
            max-height: 80vh;
            overflow-y: auto;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-color);
        }

        .modal.visible,
        .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .modal-close:hover {
            color: #fff;
        }

        .modal-title {
            margin-bottom: 20px;
            color: var(--tertiary-color);
            font-size: 1.8rem;
            border-bottom: 2px solid rgba(255, 200, 87, 0.3);
            padding-bottom: 10px;
        }

        .modal-body h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            color: var(--secondary-color);
        }

        .modal-body p,
        .modal-body li {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .modal-body ul,
        .modal-body ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .player-cards {
                flex-direction: row;
            }

            .game-board-container {
                flex-direction: column;
            }

            .player-card {
                width: 100%;
                margin-bottom: 5px;
            }

            .game-controls {
                flex-direction: column;
                gap: 15px;
            }

            .end-turn-btn {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <span class="modal-close" id="closeSettingsModal">×</span>
            <h2 class="modal-title">Game Settings</h2>
            <div class="modal-body">
                <div class="setting-row">
                    <label for="startingChargedCores">Starting Charged Cores:</label>
                    <input type="number" id="startingChargedCores" min="0" value="1">
                </div>
                <div class="setting-row">
                    <label for="turnsPerPlayerPerRound">Turns Per Player Per Round:</label>
                    <input type="number" id="turnsPerPlayerPerRound" min="1" value="1">
                </div>
                <div class="setting-row">
                    <label for="winningScore">Winning Score:</label>
                    <input type="number" id="winningScore" min="10" value="20">
                </div>
                <button id="applySettingsBtn" class="end-turn-btn">Apply Settings & New Game</button>
            </div>
        </div>
    </div>


    <div class="game-container">
        <div class="surge-overlay" id="surgeOverlay"></div>
        <div class="game-header">
            <h1>ENERGY GRID</h1>
            <p>A strategic battle of energy cores and fusion reactions</p>
        </div>

        <div class="game-content">
            <div class="game-board-container">
                <div class="player-cards">
                    <!-- Player cards will be dynamically generated here -->
                </div>

                <div class="game-board">
                    <canvas id="gameCanvas"></canvas>
                </div>
            </div>

            <div class="game-controls">
                <button id="endTurnBtn" class="end-turn-btn">End Turn</button>
            </div>
        </div>

        <div class="game-info">
            <div class="turn-info">
                <p>Current Turn: <span id="currentPlayer">Player 1</span></p>
                <!-- Add this span for the countdown -->
                <p class="surge-countdown">Energy Surge In: <span id="surgeCountdown">?</span> turns</p>
            </div>
            <div class="game-status">
                <p id="gameStatus">Game in progress...</p>
            </div>
            <div class="button-container">
                <button class="help-btn" id="settingsBtn"><i class="fas fa-cog"></i></button>
                <button class="help-btn" id="helpBtn"><i class="fas fa-question-circle"></i></button>
            </div>
        </div>
    </div>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <span class="modal-close" id="closeModal">&times;</span>
            <h2 class="modal-title">How to Play Energy Grid</h2>
            <div class="modal-body">
                <h3>Game Objective</h3>
                <p>Score the most points by creating fusions and eliminating opponent cores.</p>

                <h3>Turn Structure</h3>
                <ol>
                    <li>Your first placed core each turn is automatically an Energy Core</li>
                    <li>Any additional cores placed are Charged Cores (using your available supply)</li>
                    <li>Click "End Turn" to confirm placement</li>
                </ol>

                <h3>Placing Cores</h3>
                <p>Click on empty grid cells to select them for placement. Click again to deselect. Cores are placed at
                    the end of your turn.</p>

                <h3>Core Interactions</h3>
                <p><strong>Fusion (Same Cores):</strong> When you place a core orthogonally adjacent (not diagonally) to
                    your own cores, they fuse into a single core at the placement location. The value of the new core is
                    the sum of the fused cores.</p>
                <p><strong>Elimination (Different Cores):</strong> When you place a core orthogonally adjacent to
                    opponent cores of equal or lesser value, the opponent's cores are eliminated and returned to their
                    owner as charged cores.</p>

                <h3>Scoring</h3>
                <ul>
                    <li>Score increases by the sum of eliminated cores' values.</li>
                </ul>

                <h3>Charged Cores</h3>
                <ul>
                    <li>Players start with 0 charged cores.</li>
                    <li>Placing a charged core decreases your charged core count by 1.</li>
                    <li>When your cores are eliminated, they are returned to you as charged cores.</li>
                </ul>

                <h3>Game End</h3>
                <p>The game ends when a player reaches 20 points.</p>
            </div>
        </div>
    </div>

    <script>
        "use strict"; // Enable strict mode for better error detection

        console.log("Script loading");

        // Game constants
        const NUM_PLAYERS = 2; // Explicitly define number of players
        const GRID_SIZE = 8;
        const PLAYER_COLORS = ['#FF5A5F', '#3ECDC1']; // Player 1, Player 2
        const PLAYER_GLOW = ['rgba(255, 90, 95, 0.7)', 'rgba(62, 205, 193, 0.7)']; // Player 1, Player 2 glow
        const PLAYER_NAMES = ['Player 1', 'Player 2'];
        const WINNING_SCORE = 20;

        // Game state
        let gameState = {
            currentPlayer: 0, // 0 or 1
            players: [
                { name: PLAYER_NAMES[0], score: 0, chargedCores: [] },
                { name: PLAYER_NAMES[1], score: 0, chargedCores: [] }
            ],
            grid: [], // Will be initialized as 2D array
            selectedCells: [], // Cells selected for core placement
            selectionMode: 'energy', // 'energy' or 'charged'
            turnPhase: 'selecting', // 'selecting' or 'animation'
            placedEnergyCore: false, // Flag to track if energy Core has been placed
            gameOver: false,
            anchorCell: null,
            turnInRound: 0,
            turnsPerPlayerPerRound: 1 // Default, will be set by settings
        };

        // Canvas and rendering variables
        let canvas, ctx;
        let cellSize;
        let animationFrameId;
        let animations = [];
        let particles = []; // For particle effects

        // Critical flag to prevent rendering before initialization is complete
        let gameReadyToRender = false;

        // Debug mode
        const DEBUG = true;

        function debug(message) {
            if (DEBUG) {
                console.log(message);
                // Safely try to update game status
                try {
                    const statusElement = document.getElementById('gameStatus');
                    if (statusElement) {
                        statusElement.textContent = message;
                    }
                } catch (e) {
                    console.log("Could not update status element: " + e.message);
                }
            }
        }

        // Global helper to directly update game status for critical messages
        function updateGameStatus(message, isError = false) {
            console.log(message);

            try {
                const statusElement = document.getElementById('gameStatus');
                if (statusElement) {
                    statusElement.textContent = message;

                    if (isError) {
                        statusElement.style.color = 'red';
                        setTimeout(() => {
                            statusElement.style.color = ''; // Reset color after 3 seconds
                        }, 3000);
                    }
                }
            } catch (e) {
                console.error("Failed to update status:", e);
            }
        }

        // This function is now unused as we're initializing directly in init()
        function initGame() {
            console.log("initGame function called - but using direct initialization instead");
        }

        // Initialize the grid with empty cells
        function initGrid() {
            debug("Initializing grid");
            gameState.grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                let row = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    row.push({
                        x,
                        y,
                        core: null, // null, 'energy-0', 'energy-1', 'charged-0', 'charged-1'
                        selected: false,
                        animation: null,
                        glow: 0 // For highlighting effects
                    });
                }
                gameState.grid.push(row);
            }
            debug(`Grid initialized with size ${GRID_SIZE}x${GRID_SIZE}`);
        }

        // Resize canvas to maintain aspect ratio
        function resizeCanvas() {
            try {
                const container = canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight);
                canvas.width = size;
                canvas.height = size;
                cellSize = size / GRID_SIZE;

                debug(`Canvas resized to ${size}x${size}, cell size: ${cellSize}`);

                // Re-render after resize
                render();
            } catch (error) {
                debug("Error resizing canvas: " + error.message);
                console.error(error);
            }
        }

        // Create player cards in the DOM
        function createPlayerCards() {
            console.log("Creating player cards");

            const playerCardsContainer = document.querySelector('.player-cards');

            if (!playerCardsContainer) {
                console.error("Player cards container not found!");
                return;
            }

            playerCardsContainer.innerHTML = '';

            console.log("Player cards container found, creating cards");

            gameState.players.forEach((player, index) => {
                const playerCard = document.createElement('div');
                playerCard.className = `player-card player${index + 1}`;
                if (index === gameState.currentPlayer) {
                    playerCard.classList.add('active');
                }

                playerCard.innerHTML = `
                    <div class="turn-indicator"></div>
                    <h2 class="player-name">${player.name}</h2>
                    <div class="player-stats">
                        <div class="stat">
                            <div class="stat-value">${player.score}</div>
                            <div class="stat-label">Score</div>
                        </div>
                    </div>
                    <div class="charged-cores">
                        ${Array(player.chargedCores).fill().map(() => '<i class="charged-core-icon"></i>').join('')}
                    </div>
                `;

                playerCardsContainer.appendChild(playerCard);
                console.log(`Player ${index + 1} card created`);
            });

            console.log("All player cards created successfully");
        }

        // Update player cards with current game state
        function updatePlayerCards() {
            console.log("[DEBUG] Updating player cards");
            const playerCardsContainer = document.querySelector('.player-cards');
            if (!playerCardsContainer) {
                console.error("[DEBUG] Player cards container not found!");
                return;
            }
            playerCardsContainer.innerHTML = '';

            gameState.players.forEach((player, index) => {
                const playerCard = document.createElement('div');
                playerCard.className = `player-card player${index + 1} ${index === gameState.currentPlayer ? 'active' : ''}`;

                // *** Generate icons based on the chargedCores array ***
                const chargedCoresHTML = player.chargedCores.map(coreValue => {
                    const backgroundColor = PLAYER_COLORS[index];
                    const lighterColor = adjustColorBrightness(backgroundColor, 1.3); // Lighter for gradient
                    // Include the value inside the icon structure
                    return `<i class="charged-core-icon" style="background: radial-gradient(circle at 60% 40%, ${lighterColor}, ${backgroundColor});">
                                <span class="charged-core-value">${coreValue}</span>
                            </i>`;
                }).join('');

                playerCard.innerHTML = `
                    <div class="turn-indicator"></div>
                    <h2 class="player-name">${player.name}</h2>
                    <div class="player-stats">
                        <div class="stat">
                            <div class="stat-value">${player.score}</div>
                            <div class="stat-label">Score</div>
                        </div>
                    </div>
                    <div class="charged-cores" title="Charged Cores (Value)">
                        ${chargedCoresHTML || '<span style="font-size: 0.8em; opacity: 0.7;">No charged cores</span>'}
                    </div>
                `;
                playerCardsContainer.appendChild(playerCard);
                console.log(`[DEBUG] Updated card for Player ${index + 1} - Score: ${player.score}, Charged Cores: [${player.chargedCores.join(', ')}]`);
            });
            console.log("[DEBUG] Player cards update complete");
        }


        function adjustColorBrightness(hex, factor) {
            // Remove the '#' character, if present
            hex = hex.replace(/^#/, '');

            // Parse the hex color into its red, green, and blue components
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);

            // Adjust each component by the factor
            const newR = Math.min(255, Math.max(0, Math.round(r * factor)));
            const newG = Math.min(255, Math.max(0, Math.round(g * factor)));
            const newB = Math.min(255, Math.max(0, Math.round(b * factor)));

            // Convert the adjusted components back to hexadecimal
            const newHexR = newR.toString(16).padStart(2, '0');
            const newHexG = newG.toString(16).padStart(2, '0');
            const newHexB = newB.toString(16).padStart(2, '0');

            // Combine the adjusted components into a new hex color
            return `#${newHexR}${newHexG}${newHexB}`;
        }

        // Set the current selection mode
        function setSelectionMode(mode) {
            console.log(`Selection mode change requested: ${mode}`);

            // Don't allow changing if game is over
            if (gameState.gameOver) {
                console.log("Game is over, ignoring selection mode change");
                return;
            }

            // Don't switch to charged if player has no charged cores
            if (mode === 'charged' && gameState.players[gameState.currentPlayer].chargedCores <= 0) {
                console.log("Player has no charged cores available");
                updateGameStatus("No charged cores available!", true);
                setTimeout(() => {
                    updateGameStatus("Game in progress...");
                }, 2000);
                return;
            }

            gameState.selectionMode = mode;
            console.log(`Selection mode changed to: ${mode}`);
            updateGameStatus(`Selected ${mode} core placement mode`);
        }

        // Handle canvas click events
        function handleCanvasClick(event) {
            console.log("\n[DEBUG - CLICK] ========== Canvas Click Event ==========");
            console.log("[DEBUG - CLICK] Current charged cores - P1:", gameState.players[0].chargedCores, "P2:", gameState.players[1].chargedCores);
            console.log("[DEBUG - CLICK] Current player:", gameState.currentPlayer + 1);
            console.log("[DEBUG - CLICK] Selected cells count:", gameState.selectedCells.length);
            console.log("[DEBUG - CLICK] Energy Core placed:", gameState.placedEnergyCore);

            // 1. Preliminary Checks
            if (!preliminaryChecks()) return;

            // 2. Get Click Coordinates
            const { x, y } = getGridCoordinates(event);
            if (x === null) return; // Click was outside grid

            // 3. Handle Cell Selection
            handleCellSelection(x, y);
        }

        // 1. Preliminary Checks (Game Ready, Turn Phase)
        function preliminaryChecks() {
            if (!gameReadyToRender) {
                console.log("[DEBUG - CLICK] Game not ready for interaction");
                updateGameStatus("Game still initializing...");
                return false;
            }

            if (gameState.turnPhase !== 'selecting' || gameState.gameOver) {
                console.log("[DEBUG - CLICK] Turn phase or game state prevents selection");
                updateGameStatus(gameState.gameOver ? "Game is over!" : "Cannot select during animations");
                return false;
            }
            return true;
        }

        // 2. Get Grid Coordinates from Click Event
        function getGridCoordinates(event) {
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            const x = Math.floor(clickX / cellSize);
            const y = Math.floor(clickY / cellSize);

            console.log(`[DEBUG - CLICK] Grid position clicked: (${x}, ${y})`);

            if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) {
                console.log("[DEBUG - CLICK] Click outside grid bounds");
                updateGameStatus("Click outside grid bounds");
                return { x: null, y: null };
            }

            return { x, y };
        }

        // 3. Handle Cell Selection/Deselection Logic
        function handleCellSelection(x, y) {
            try {
                const cell = gameState.grid[y][x];
                if (!cell) {
                    console.error(`[DEBUG - CLICK] Cell at (${x}, ${y}) is undefined!`);
                    return;
                }

                console.log(`[DEBUG - CLICK] Cell state: occupied=${cell.core ? 'yes' : 'no'}, selected=${cell.selected}`);

                if (cell.selected) {
                    deselectCell(x, y, cell);
                } else {
                    selectCell(x, y, cell);
                }

                // Force re-render
                render();

                console.log("[DEBUG - CLICK] Final state - Charged cores - P1:", gameState.players[0].chargedCores, "P2:", gameState.players[1].chargedCores);
                console.log("[DEBUG - CLICK] Selected cells:", gameState.selectedCells);
                console.log("[DEBUG - CLICK] ========== End Click Event ==========\n");

            } catch (error) {
                console.error("[DEBUG - CLICK] Error handling grid click:", error);
                updateGameStatus("Error processing selection", true);
            }
        }

        // 3a. Deselect Cell
        function deselectCell(x, y, cell) {
            console.log("[DEBUG - CLICK] Deselecting cell at (" + x + ", " + y + ")");
            const player = gameState.players[gameState.currentPlayer];

            const index = gameState.selectedCells.findIndex(selected => selected.x === x && selected.y === y);

            if (index !== -1) {
                const deselectedCellInfo = gameState.selectedCells[index];
                console.log(`[DEBUG - CLICK] Found cell to deselect at index ${index}, type: ${deselectedCellInfo.type}, value: ${deselectedCellInfo.value}`);

                if (deselectedCellInfo.type === 'energy') {
                    console.log("[DEBUG - CLICK] Anchor/Energy core deselected. Resetting all turn selections.");
                    let refundedCoresInfo = [];
                    gameState.selectedCells.forEach(selected => {
                        if (selected.type === 'charged') {
                            // Return the *value* back to the player's array
                            player.chargedCores.push(selected.value);
                            refundedCoresInfo.push(selected.value);
                        }
                        try {
                            gameState.grid[selected.y][selected.x].selected = false;
                        } catch (e) {
                            console.warn(`Error visually deselecting ${selected.x},${selected.y}: ${e.message}`);
                        }
                    });

                    if (refundedCoresInfo.length > 0) {
                        console.log(`[DEBUG - CLICK] Returned ${refundedCoresInfo.length} charged cores with values [${refundedCoresInfo.join(', ')}] due to anchor deselect. Player ${gameState.currentPlayer + 1} cores: [${player.chargedCores.join(', ')}]`);
                        updatePlayerCards(); // Update UI immediately
                    }

                    gameState.selectedCells = [];
                    gameState.placedEnergyCore = false;
                    gameState.anchorCell = null;
                    console.log("[DEBUG - CLICK] selectedCells, placedEnergyCore, anchorCell reset.");
                    updateGameStatus("Selection cleared. Place energy core first.");

                } else { // Deselecting a 'charged' core
                    console.log("[DEBUG - CLICK] Deselecting a charged core.");
                    // Return the specific core's value
                    player.chargedCores.push(deselectedCellInfo.value);
                    console.log(`[DEBUG - CLICK] Returned charged core with value ${deselectedCellInfo.value}. Player ${gameState.currentPlayer + 1} cores: [${player.chargedCores.join(', ')}]`);
                    updatePlayerCards();

                    gameState.selectedCells.splice(index, 1);
                    console.log("[DEBUG - CLICK] Cell removed from selectedCells, new count:", gameState.selectedCells.length);
                    cell.selected = false; // Visual deselection
                    updateGameStatus("Charged core deselected.");

                    if (gameState.selectedCells.length === 0) {
                        console.log("[DEBUG - CLICK] Last selected cell deselected, ensuring anchor/energy flags reset.");
                        gameState.placedEnergyCore = false;
                        gameState.anchorCell = null;
                    }
                }
            } else {
                console.warn(`[DEBUG - CLICK] Could not find cell (${x}, ${y}) in selectedCells array to deselect.`);
                cell.selected = false; // Attempt visual deselection anyway
            }
            render(); // Re-render after any deselection
        }


        // 3b. Select Cell
        function selectCell(x, y, cell) {
            console.log("[DEBUG - CLICK] Attempting to select empty cell");
            const player = gameState.players[gameState.currentPlayer];

            if (!gameState.placedEnergyCore && gameState.selectedCells.length > 0) {
                updateGameStatus("Energy core must be placed first", true);
                setTimeout(() => updateGameStatus("Game in progress..."), 2000);
                return;
            }

            const coreType = gameState.selectedCells.length === 0 ? 'energy' : 'charged';

            if (coreType === 'energy' && gameState.placedEnergyCore) {
                updateGameStatus("Energy core already placed", true);
                setTimeout(() => updateGameStatus("Game in progress..."), 2000);
                return;
            }

            // *** Modify Charged Core Selection Logic ***
            let coreValueToPlace = 1; // Default for energy core
            if (coreType === 'charged') {
                // Check if player has any charged cores left
                if (player.chargedCores.length === 0) {
                    console.log("[DEBUG - CLICK] No charged cores available");
                    updateGameStatus("No charged cores available!", true);
                    setTimeout(() => updateGameStatus("Game in progress..."), 2000);
                    return;
                }
                // Get the value of the core being placed (e.g., the last one)
                // and remove it from the player's hand
                coreValueToPlace = player.chargedCores.pop(); // Remove last core & get its value
                console.log(`[DEBUG - CLICK] Using charged core with value ${coreValueToPlace}. Player ${gameState.currentPlayer + 1} remaining cores: [${player.chargedCores.join(', ')}]`);
                updatePlayerCards(); // Update UI immediately
                updateGameStatus("Charged core selected");
            }

            if (gameState.selectedCells.length === 0) {
                gameState.anchorCell = { x: x, y: y };
                console.log(`[DEBUG - CLICK] Set anchor cell to (${x}, ${y})`);
            }

            if (coreType === 'energy') {
                gameState.placedEnergyCore = true;
                console.log("[DEBUG - CLICK] Energy Core selected, placedEnergyCore set to true");
                updateGameStatus("Energy core selected");
            }

            cell.selected = true;
            // Store the value along with the selection
            gameState.selectedCells.push({ x, y, type: coreType, value: coreValueToPlace });
            console.log(`[DEBUG - CLICK] Cell selected at (${x}, ${y}), type: ${coreType}, value: ${coreValueToPlace}`);
            addSelectionParticles(x, y);
        }

        // Add particles for selection feedback
        function addSelectionParticles(x, y) {
            const centerX = x * cellSize + cellSize / 2;
            const centerY = y * cellSize + cellSize / 2;

            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                const lifespan = 30 + Math.random() * 20;

                particles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 2 + Math.random() * 3,
                    color: PLAYER_COLORS[gameState.currentPlayer],
                    alpha: 1,
                    life: lifespan,
                    maxLife: lifespan
                });
            }
        }

        // End the current turn
        function endTurn() {
            console.log("\n========== TURN START ==========");
            console.log(`Player ${gameState.currentPlayer + 1}'s turn`);
            console.log(`Charged Cores - P1: [${gameState.players[0].chargedCores.join(',')}] (${gameState.players[0].chargedCores.length}), P2: [${gameState.players[1].chargedCores.join(',')}] (${gameState.players[1].chargedCores.length})`);            logBoardState("Initial ");
            console.log("[DEBUG] End turn requested");
            console.log("[DEBUG] Current charged cores - P1:", gameState.players[0].chargedCores, "P2:", gameState.players[1].chargedCores);

            if (!gameReadyToRender) {
                console.log("[DEBUG] Game not ready for turn end");
                updateGameStatus("Game still initializing...");
                return;
            }

            if (gameState.turnPhase !== 'selecting' || gameState.gameOver) {
                console.log("[DEBUG] Cannot end turn: phase =", gameState.turnPhase, "gameOver =", gameState.gameOver);
                updateGameStatus(gameState.gameOver ? "Game is over!" : "Cannot end turn during animations");
                return;
            }

            // Verify placed an energy Core
            if (!gameState.placedEnergyCore) {
                console.log("[DEBUG] No energy Core placed");
                updateGameStatus("You must place one energy core!", true);
                setTimeout(() => {
                    updateGameStatus("Game in progress...");
                }, 2000);
                return;
            }

            // Verify player has enough charged Cores
            const chargedCount = gameState.selectedCells.filter(cell => cell.type === 'charged').length;
            console.log("[DEBUG] Attempting to place", chargedCount, "charged cores");
            console.log(`Player ${gameState.currentPlayer + 1} has ${gameState.players[gameState.currentPlayer].chargedCores.length} charged cores available`);            try {
                // Change phase to animation
                gameState.turnPhase = 'animation';
                console.log("[DEBUG] Turn phase changed to animation");
                updateGameStatus("Processing turn...");

                // Place Cores on the grid
                placeCores();
                console.log("[DEBUG] Cores placed on grid");
                console.log("[DEBUG] Current charged Cores - P1:", gameState.players[0].chargedCores, "P2:", gameState.players[1].chargedCores);

                // Reset energy Core flag for next turn
                gameState.placedEnergyCore = false;

                // Check for fusions and eliminations
                console.log("[DEBUG] Scheduling core interactions processing");
                setTimeout(() => {
                    processCoreInteractions();
                }, 600);
            } catch (error) {
                console.error("Error ending turn:", error);
                gameState.turnPhase = 'selecting'; // Reset phase on error
                updateGameStatus("Error processing turn", true);
            }
        }
        // Global variables to store settings
        let startingChargedCores = 1;
        let winningScore = 20;
        let turnsPerPlayerPerRoundSetting = 1; // Default for settings input

        // Show settings modal
        function showSettingsModal() {
            const modal = document.getElementById('settingsModal');
            modal.classList.add('visible');
            document.getElementById('startingChargedCores').value = startingChargedCores;
            document.getElementById('turnsPerPlayerPerRound').value = turnsPerPlayerPerRoundSetting;
            document.getElementById('winningScore').value = winningScore;

            setTimeout(() => {
                modal.querySelector('.modal-content').style.opacity = 1;
                modal.querySelector('.modal-content').style.transform = 'translateY(0)';
            }, 50);
        }

        // Hide settings modal
        function hideSettingsModal() {
            const modal = document.getElementById('settingsModal');
            const content = modal.querySelector('.modal-content');
            content.style.opacity = 0;
            content.style.transform = 'translateY(20px)';
            setTimeout(() => {
                modal.classList.remove('visible');
            }, 300);
        }

        function applySettingsAndNewGame() {
            startingChargedCores = parseInt(document.getElementById('startingChargedCores').value) || 0; // Can start with 0
            winningScore = parseInt(document.getElementById('winningScore').value) || 20;
            turnsPerPlayerPerRoundSetting = parseInt(document.getElementById('turnsPerPlayerPerRound').value) || 1;

            if (isNaN(startingChargedCores) || startingChargedCores < 0 || isNaN(winningScore) || winningScore < 1 || isNaN(turnsPerPlayerPerRoundSetting) || turnsPerPlayerPerRoundSetting < 1) {
                alert("Please enter valid numbers (Cores >= 0, Value >= 1, Score >= 1, Turns >= 1).");
                return;
            }
            hideSettingsModal();
            newGame();
        }

        function newGame() {
            console.log("Starting a new game with settings:");
            console.log("Starting Charged Cores Count:", startingChargedCores);
            console.log("Winning Score:", winningScore);
            console.log("Turns Per Player Per Round:", turnsPerPlayerPerRoundSetting);

            // *** Initialize cores with value 1 ***
            const initialValue = 1; // Cores always start at 1
            const initialCoresP1 = Array(startingChargedCores).fill(initialValue);
            const initialCoresP2 = Array(startingChargedCores).fill(initialValue);
            console.log(`Initializing Player 1 with ${startingChargedCores} cores, value ${initialValue}`);
            console.log(`Initializing Player 2 with ${startingChargedCores} cores, value ${initialValue}`);

            gameState = {
                currentPlayer: 0,
                players: [
                    { name: PLAYER_NAMES[0], score: 0, chargedCores: initialCoresP1 },
                    { name: PLAYER_NAMES[1], score: 0, chargedCores: initialCoresP2 }
                ],
                grid: [],
                selectedCells: [],
                selectionMode: 'energy',
                turnPhase: 'selecting',
                placedEnergyCore: false,
                gameOver: false,
                anchorCell: null,
                turnInRound: 0,
                turnsPerPlayerPerRound: turnsPerPlayerPerRoundSetting
            };

            initGrid();
            updatePlayerCards(); // Display initial cores
            updateGameStatus(`${gameState.players[gameState.currentPlayer].name}'s turn`);
            updateSurgeCountdown();
            setSelectionMode('energy');

            const surgeOverlay = document.getElementById('surgeOverlay');
            if (surgeOverlay) {
                surgeOverlay.classList.remove('active');
                surgeOverlay.style.opacity = '0';
            }

            if (gameState.gameOver) {
                gameState.gameOver = false;
                animations = [];
                particles = [];
                cancelAnimationFrame(animationFrameId);
                gameLoop();
            } else if (!animationFrameId) {
                gameLoop();
            }
        }

        function placeCores() {
            try {
                console.log(`Placing ${gameState.selectedCells.length} Cores on the grid`);
                const placedPositions = [];

                gameState.selectedCells.forEach(selected => {
                    const { x, y, type, value } = selected; // Get value from selected data

                    gameState.grid[y][x].core = `${type}-${gameState.currentPlayer}`;
                    // Use the value associated with the selection for the grid cell
                    gameState.grid[y][x].value = value; // VALUE IS SET HERE
                    gameState.grid[y][x].selected = false;
                    gameState.grid[y][x].justPlaced = true;

                    placedPositions.push({ x, y });
                    console.log(`Placed ${type} Core at (${x}, ${y}) with value ${gameState.grid[y][x].value}`);

                    animations.push({
                        type: 'placement',
                        x, y, progress: 0, duration: 40,
                        coreType: type, player: gameState.currentPlayer, value: value // Pass value to animation? (optional)
                    });
                });
                gameState.selectedCells = []; // Clear after processing
            } catch (error) {
                console.error("Error placing Cores:", error);
            }
        }

        // Process core interactions (fusions and eliminations)
                // Process core interactions (fusions and eliminations)
                function processCoreInteractions() {
            try {
                console.log("\n----- Processing Core Interactions -----");

                // --- Find newly placed cores ---
                const newCores = []; // {x, y, value}
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const cell = gameState.grid[y][x];
                        if (cell && cell.core && cell.justPlaced) {
                            newCores.push({ x, y, value: cell.value });
                             console.log(`Detected new core at (${x}, ${y}) with value ${cell.value}`);
                        }
                    }
                }
                 console.log(`Found ${newCores.length} newly placed cores.`);


                // --- Detect Initial Eliminations ---
                const eliminations = []; // {x, y, Core, coreType, player, eliminatedBy, value}
                const eliminatedPositions = new Set(); // Track positions to avoid double elimination check per turn phase
                 console.log("--- Checking Initial Eliminations ---");
                 newCores.forEach(core => {
                    const placedCoreValue = core.value;
                    const adjacentCells = getAdjacentCells(core.x, core.y);
                    // console.log(`Checking elims FROM new core at (${core.x}, ${core.y}), value ${placedCoreValue}`);

                    adjacentCells.forEach(adjInfo => {
                        const adjCell = adjInfo.cell;
                        if (!adjCell.core) return; // Skip empty adjacent cells

                        const adjCoreParts = adjCell.core.split('-');
                        const adjPlayer = parseInt(adjCoreParts[1]);
                        const adjCoreValue = adjCell.value;
                        const posKey = `${adjInfo.x},${adjInfo.y}`;

                        // Check if opponent, value allows elimination, and not already marked for elimination
                        if (adjPlayer !== gameState.currentPlayer && placedCoreValue >= adjCoreValue && !eliminatedPositions.has(posKey)) { // Use >= for elimination
                            eliminatedPositions.add(posKey);
                            console.log(`Found initial elimination at (${adjInfo.x}, ${adjInfo.y}): PlacedValue ${placedCoreValue} >= OpponentValue ${adjCoreValue}`);
                            eliminations.push({
                                x: adjInfo.x, y: adjInfo.y, core: adjCell.core, coreType: adjCoreParts[0],
                                player: adjPlayer, eliminatedBy: gameState.currentPlayer, value: adjCoreValue
                            });
                        } else if (adjPlayer !== gameState.currentPlayer) {
                            // console.log(`Skipping initial elimination at (${adjInfo.x}, ${adjInfo.y}): Check failed (Value: ${adjCoreValue} vs ${placedCoreValue})`);
                        }
                    });
                });

                // --- Detect Fusions ---
                const fusions = []; // {cells: [{x,y}], player, newValue, resultType, targetCell: {x,y}}
                const processedForFusion = new Set(); // Track cells already part of a fusion this turn
                 console.log("--- Checking Fusions ---");
                 newCores.forEach(newCore => {
                    const startPosKey = `${newCore.x},${newCore.y}`;
                    if (processedForFusion.has(startPosKey)) return; // Skip if already part of another fusion found

                    const startCell = gameState.grid[newCore.y]?.[newCore.x];
                    if (!startCell || !startCell.core) return; // Safety check

                    const startCoreParts = startCell.core.split('-');
                    const player = parseInt(startCoreParts[1]);

                    // Start BFS from this new core
                    const fusionCellsCoords = []; // Store {x,y} coords of cells in this fusion
                    const queue = [{ x: newCore.x, y: newCore.y }];
                    const visitedInThisBFS = new Set([startPosKey]); // Track visited for *this specific* BFS run
                    let totalValue = 0;
                    let hasChargedCore = false; // Does the fusion contain any charged cores?

                    while (queue.length > 0) {
                        const currentCoord = queue.shift();
                        const currentCell = gameState.grid[currentCoord.y]?.[currentCoord.x];
                         if (!currentCell || !currentCell.core) continue; // Safety check

                        fusionCellsCoords.push({ x: currentCoord.x, y: currentCoord.y });
                        processedForFusion.add(`${currentCoord.x},${currentCoord.y}`); // Mark globally processed
                        totalValue += currentCell.value;
                         if (currentCell.core.startsWith('charged')) hasChargedCore = true;

                        // Check adjacent cells
                        const adjacentCells = getAdjacentCells(currentCoord.x, currentCoord.y);
                        adjacentCells.forEach(adjInfo => {
                            const adjCell = adjInfo.cell;
                            const adjKey = `${adjInfo.x},${adjInfo.y}`;

                            // Check if valid adjacent cell, has a core, belongs to same player, and not visited in this BFS
                            if (adjCell && adjCell.core && !visitedInThisBFS.has(adjKey)) {
                                const adjCoreParts = adjCell.core.split('-');
                                if (parseInt(adjCoreParts[1]) === player) {
                                    visitedInThisBFS.add(adjKey); // Mark visited for this BFS
                                    queue.push({ x: adjInfo.x, y: adjInfo.y });
                                }
                            }
                        });
                    }

                    // If more than one cell was involved, it's a fusion
                    if (fusionCellsCoords.length > 1) {
                        console.log(`Found fusion involving ${fusionCellsCoords.length} cells. Total value: ${totalValue}`);
                        fusions.push({
                            cells: fusionCellsCoords, // Pass coordinates
                            player: player, newValue: totalValue,
                            resultType: hasChargedCore ? 'charged' : 'energy', // Result type depends on components
                            targetCell: { x: newCore.x, y: newCore.y } // Initial target is the new core that started the check
                        });
                    }
                });
                // --- End Fusion Detection ---

                console.log(`Found ${fusions.length} fusions and ${eliminations.length} initial eliminations`); // This log should now be accurate

                // --- Clear justPlaced Flags ---
                 newCores.forEach(core => {
                    // Add extra safety check for cell existence
                    if (gameState.grid[core.y] && gameState.grid[core.y][core.x]) {
                       gameState.grid[core.y][core.x].justPlaced = false;
                    } else {
                        console.warn(`Attempted to clear justPlaced flag on missing cell (${core.x}, ${core.y})`);
                    }
                });


                // --- Process Interactions (Fusions first, then Eliminations) ---
                 if (fusions.length > 0) {
                    // Animate fusions
                     fusions.forEach(fusion => {
                         animations.push({
                            type: 'fusion',
                            cells: fusion.cells, // Pass coordinates if needed
                            progress: 0, duration: 50,
                            player: fusion.player, newValue: fusion.newValue,
                            resultType: fusion.resultType, targetCell: fusion.targetCell
                        });
                     });

                     setTimeout(() => {
                         // Apply actual state changes from fusions
                         applyFusions(fusions);

                         // Check for post-fusion eliminations
                         const postFusionEliminations = [];
                         const postFusionEliminatedPositions = new Set();
                         console.log("--- Checking Post-Fusion Eliminations ---");
                         const fusionResultCoords = new Set();
                         fusions.forEach(f => {
                              let targetCoord = f.targetCell;
                               if (gameState.anchorCell && f.cells.some(c => c.x === gameState.anchorCell.x && c.y === gameState.anchorCell.y)) {
                                   targetCoord = gameState.anchorCell;
                               }
                               fusionResultCoords.add(`${targetCoord.x},${targetCoord.y}`);
                         });

                         fusionResultCoords.forEach(coordKey => {
                             const [fx, fy] = coordKey.split(',').map(Number);
                             const fusedCell = gameState.grid[fy]?.[fx];

                             if (fusedCell && fusedCell.core && fusedCell.core.endsWith(`-${gameState.currentPlayer}`)) {
                                 const fusedValue = fusedCell.value;
                                 console.log(`Checking eliminations FROM post-fusion core at (${fx}, ${fy}) with value ${fusedValue}`);
                                 const adjacentCells = getAdjacentCells(fx, fy);
                                 adjacentCells.forEach(adjInfo => {
                                     const adjCell = adjInfo.cell;
                                     if (!adjCell.core) return;
                                     const adjCoreParts = adjCell.core.split('-');
                                     const adjPlayer = parseInt(adjCoreParts[1]);
                                     const adjCoreValue = adjCell.value;
                                     const posKey = `${adjInfo.x},${adjInfo.y}`;

                                     // Post-fusion elimination check: Use >=
                                     if (adjPlayer !== gameState.currentPlayer && fusedValue >= adjCoreValue && !postFusionEliminatedPositions.has(posKey)) {
                                         postFusionEliminatedPositions.add(posKey);
                                         console.log(`Found post-fusion elimination at (${adjInfo.x}, ${adjInfo.y}): FusedValue ${fusedValue} >= OpponentValue ${adjCoreValue}`);
                                         postFusionEliminations.push({
                                             x: adjInfo.x, y: adjInfo.y, core: adjCell.core, coreType: adjCoreParts[0],
                                             player: adjPlayer, eliminatedBy: gameState.currentPlayer, value: adjCoreValue
                                         });
                                     } else if (adjPlayer !== gameState.currentPlayer) {
                                         console.log(`Skipping post-fusion elimination at (${adjInfo.x}, ${adjInfo.y}): Check failed (Value: ${adjCoreValue} vs ${fusedValue})`);
                                     }
                                 });
                             } else {
                                 console.warn(`Could not find expected fusion result at (${fx}, ${fy}) or it didn't belong to current player.`);
                             }
                         });
                         // --- End Post-Fusion Check ---


                         // Combine initial and post-fusion eliminations, ensuring uniqueness
                         const allElims = [...eliminations, ...postFusionEliminations]; // Combine before checking uniqueness
                         const uniqueElims = [];
                         const uniqueElimPos = new Set();
                         allElims.forEach(elim => {
                             const key = `${elim.x},${elim.y}`;
                             if (!uniqueElimPos.has(key)) {
                                 uniqueElims.push(elim);
                                 uniqueElimPos.add(key);
                             } else {
                                 console.log(`Duplicate elimination detected and skipped for (${elim.x}, ${elim.y})`);
                             }
                         });


                         if (uniqueElims.length > 0) {
                              console.log(`Processing ${uniqueElims.length} total unique eliminations.`);
                             processEliminations(uniqueElims); // Process combined list
                         } else {
                             console.log("No eliminations to process after fusions.");
                             finishTurn(); // No elims after fusion
                         }
                     }, 600); // Delay for fusion animation visual

                 } else if (eliminations.length > 0) {
                     // Process only initial eliminations if no fusions occurred
                      console.log(`Processing ${eliminations.length} initial eliminations (no fusions).`);
                     processEliminations(eliminations);
                 } else {
                     // No interactions at all
                      console.log("No fusions or eliminations occurred this turn.");
                     finishTurn();
                 }

            } catch (error) {
                console.error("Error processing core interactions:", error);
                gameState.turnPhase = 'selecting'; // Reset phase on error
                updateGameStatus("Error processing turn", true);
                // Attempt to finish turn gracefully even on error
                setTimeout(finishTurn, 100);
            }
        }


        // Check for core interactions
        function checkCoreInteractions() {
            try {
                console.log("Checking for core interactions");
                const fusions = [];
                const eliminations = [];
                const processedCells = new Set(); // Track cells we've processed to avoid duplicates

                // Helper function to add a cell to the processed set
                const markProcessed = (x, y) => processedCells.add(`${x},${y}`);
                const isProcessed = (x, y) => processedCells.has(`${x},${y}`);

                // First pass: Find all newly placed Cores
                const placedCores = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const cell = gameState.grid[y][x];
                        if (!cell.core) continue;

                        // Consider this a "newly placed" core if it was part of the current turn
                        const coreParts = cell.core.split('-');
                        const player = parseInt(coreParts[1]);

                        if (player === gameState.currentPlayer) {
                            placedCores.push({ x, y, player });
                        }
                    }
                }

                console.log(`Found ${placedCores.length} Cores from current player`);

                // Process fusion chains
                placedCores.forEach(core => {
                    // Skip if this cell was already processed in a previous fusion
                    if (isProcessed(core.x, core.y)) return;

                    // Start a new fusion chain from this core
                    const fusionChain = [];
                    const coreQueue = [core];

                    // BFS to find all connected cores of the same player
                    while (coreQueue.length > 0) {
                        const current = coreQueue.shift();

                        // Skip if already processed
                        if (isProcessed(current.x, current.y)) continue;

                        // Add to fusion chain and mark as processed
                        fusionChain.push(current);
                        markProcessed(current.x, current.y);

                        // Get adjacent cells with cores from the same player
                        const adjacentCells = getAdjacentCells(current.x, current.y);

                        adjacentCells.forEach(adjInfo => {
                            const adjCell = adjInfo.cell;
                            if (!adjCell.core) return;

                            const adjCoreParts = adjCell.core.split('-');
                            const adjPlayer = parseInt(adjCoreParts[1]);

                            // If same player and not processed, add to queue
                            if (adjPlayer === current.player && !isProcessed(adjInfo.x, adjInfo.y)) {
                                coreQueue.push({
                                    x: adjInfo.x,
                                    y: adjInfo.y,
                                    player: adjPlayer
                                });
                            }
                        });
                    }

                    // If we found more than 1 core in the chain, it's a fusion
                    if (fusionChain.length > 1) {
                        console.log(`Found fusion chain with ${fusionChain.length} cores`);

                        // Calculate total value of fusion
                        let totalValue = 0;
                        fusionChain.forEach(cell => {
                            const cellValue = gameState.grid[cell.y][cell.x].value ||
                                (gameState.grid[cell.y][cell.x].core.startsWith('charged') ? 2 : 1);
                            totalValue += cellValue;
                        });

                        fusions.push({
                            cells: fusionChain.map(cell => ({ x: cell.x, y: cell.y })),
                            player: core.player,
                            newValue: totalValue
                        });
                    }
                });

                // Reset processed cells tracker for eliminations
                processedCells.clear();

                // Check for eliminations by checking all opponent cores adjacent to current player cores
                placedCores.forEach(core => {
                    const adjacentCells = getAdjacentCells(core.x, core.y);

                    adjacentCells.forEach(adjInfo => {
                        const adjCell = adjInfo.cell;
                        if (!adjCell.core) return;

                        const adjCoreParts = adjCell.core.split('-');
                        const adjPlayer = parseInt(adjCoreParts[1]);

                        // If opponent core and not already processed
                        if (adjPlayer !== core.player && !isProcessed(adjInfo.x, adjInfo.y)) {
                            markProcessed(adjInfo.x, adjInfo.y);

                            // Add to eliminations
                            eliminations.push({
                                x: adjInfo.x,
                                y: adjInfo.y,
                                core: adjCell.core,
                                coreType: adjCoreParts[0],
                                player: adjPlayer,
                                eliminatedBy: core.player,
                                value: adjCell.value || (adjCoreParts[0] === 'energy' ? 1 : 2)
                            });
                        }
                    });
                });

                console.log(`Found ${fusions.length} fusions and ${eliminations.length} eliminations`);
                return { fusions, eliminations };
            } catch (error) {
                console.error("Error checking core interactions:", error);
                return { fusions: [], eliminations: [] };
            }
        }

        // Apply fusion results
        function applyFusions(fusions) {
            try {
                console.log("\n----- Applying Fusions -----");
                fusions.forEach(fusion => {
                    console.log(`Applying fusion: ${fusion.cells.length} cells with new value ${fusion.newValue}`);
                    // Determine target cell (prioritize anchor if valid, else use the newCore coord)
                    let targetCoord = fusion.targetCell;
                    if (gameState.anchorCell && fusion.cells.some(c => c.x === gameState.anchorCell.x && c.y === gameState.anchorCell.y)) {
                        console.log("Using anchor cell as fusion target.");
                        targetCoord = gameState.anchorCell;
                    } else {
                        console.log("Using newly placed core as fusion target.");
                    }

                    const targetCell = gameState.grid[targetCoord.y][targetCoord.x];
                    targetCell.core = `${fusion.resultType}-${fusion.player}`;
                    targetCell.value = fusion.newValue; // Set the calculated total value
                    targetCell.glow = 1; // Add glow effect
                    console.log(`Fusion result at (${targetCoord.x}, ${targetCoord.y}): ${targetCell.core} with value ${targetCell.value}`);

                    // Remove other cells involved
                    fusion.cells.forEach(coord => {
                        if (coord.x !== targetCoord.x || coord.y !== targetCoord.y) {
                            console.log(`Removing fused core at (${coord.x}, ${coord.y})`);
                            const cellToRemove = gameState.grid[coord.y][coord.x];
                            cellToRemove.core = null;
                            cellToRemove.value = null; // Clear value too
                            cellToRemove.glow = 0;
                        }
                    });
                });
                // Don't update player cards here, happens after eliminations/finishTurn
                console.log("Fusions applied successfully");
            } catch (error) {
                console.error("Error applying fusions:", error);
            }
        }

        // Process eliminations
        function processEliminations(eliminations) {
            try {
                console.log("\n----- Processing Eliminations -----");
                if (!eliminations || eliminations.length === 0) {
                    console.log("No eliminations to process.");
                    finishTurn(); return;
                }
                console.log(`Processing ${eliminations.length} eliminations`);

                let totalEliminatedValueForScore = 0;
                // Group eliminations by the player whose core is being returned
                const returnedCoresCountByPlayer = {}; // { playerIndex: count }

                eliminations.forEach(elim => {
                    console.log(`Elimination at (${elim.x}, ${elim.y}): core ${elim.core}, Value ${elim.value}, By Player ${elim.eliminatedBy + 1}`);
                    animations.push({ /* ... elimination animation data ... */ });

                    // Score is based on the value of the core on the board when eliminated
                    totalEliminatedValueForScore += elim.value;

                    // Increment the count of cores to be returned to the owner
                    if (!returnedCoresCountByPlayer[elim.player]) {
                        returnedCoresCountByPlayer[elim.player] = 0;
                    }
                    returnedCoresCountByPlayer[elim.player]++; // Just count how many need returning

                    // Remove core from the grid
                    const cell = gameState.grid[elim.y][elim.x];
                    cell.core = null;
                    cell.value = null;
                });

                // *** Return cores with value 1 to owners ***
                for (const [playerId, countToReturn] of Object.entries(returnedCoresCountByPlayer)) {
                    const playerIndex = parseInt(playerId);
                    const player = gameState.players[playerIndex];
                    const oldCount = player.chargedCores.length;
                    const returnedValue = 1; // Returned cores ALWAYS have value 1

                    for (let i = 0; i < countToReturn; i++) {
                        player.chargedCores.push(returnedValue); // Add a core with value 1
                    }
                    console.log(`[DEBUG] Player ${playerIndex + 1} received ${countToReturn} returned core(s), each with value ${returnedValue}. Charged cores: ${oldCount} -> ${player.chargedCores.length}`);
                }

                // Award score to the current player (attacker)
                if (totalEliminatedValueForScore > 0) {
                    gameState.players[gameState.currentPlayer].score += totalEliminatedValueForScore;
                    console.log(`[DEBUG] Player ${gameState.currentPlayer + 1} gains ${totalEliminatedValueForScore} points (from eliminated core values). New score: ${gameState.players[gameState.currentPlayer].score}`);
                    animations.push({ /* ... score update animation data ... */ });
                }

                setTimeout(finishTurn, 600); // Delay for animation

            } catch (error) {
                console.error("Error processing eliminations:", error);
                finishTurn(); // Try to recover
            }
        }



        // Helper function to get the value of a cell's core
        function getCellValue(x, y) {
            const core = gameState.grid[y][x].core;
            if (!core) return 0;
            const coreParts = core.split('-');
            const type = coreParts[0];
            return type === 'energy' ? 1 : 2; // Energy cores = 1, Charged = 2
        }

        // Helper function to get adjacent cells (only horizontal and vertical, no diagonals)
        function getAdjacentCells(x, y) {
            const adjacentCells = [];
            const directions = [
                { dx: 1, dy: 0 },   // right
                { dx: -1, dy: 0 },  // left
                { dx: 0, dy: 1 },   // down
                { dx: 0, dy: -1 }   // up
                // Removed diagonal directions as requested
            ];

            directions.forEach(dir => {
                const nx = x + dir.dx;
                const ny = y + dir.dy;

                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    adjacentCells.push({
                        cell: gameState.grid[ny][nx],
                        x: nx,
                        y: ny
                    });
                }
            });
            return adjacentCells;
        }

        // Check for eliminations
        function checkEliminations() {
            const eliminations = [];

            // Check for surrounded opponent cores (horizontally, vertically, diagonally)
            const directions = [
                { dx: 1, dy: 0 },   // right
                { dx: -1, dy: 0 },  // left
                { dx: 0, dy: 1 },   // down
                { dx: 0, dy: -1 },  // up
                { dx: 1, dy: 1 },   // down-right
                { dx: -1, dy: -1 }, // up-left
                { dx: 1, dy: -1 },  // up-right
                { dx: -1, dy: 1 }   // down-left
            ];

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = gameState.grid[y][x];
                    if (!cell.core) continue;

                    // Get player from core
                    const coreParts = cell.core.split('-');
                    const coreType = coreParts[0];
                    const defender = parseInt(coreParts[1]);

                    // For each possible attacker
                    for (let attacker = 0; attacker < 2; attacker++) {
                        // Skip if checking against own cores
                        if (attacker === defender) continue;

                        // Count surrounding attacker cores
                        let surroundCount = 0;

                        directions.forEach(dir => {
                            const nx = x + dir.dx;
                            const ny = y + dir.dy;

                            if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                                const neighborCell = gameState.grid[ny][nx];
                                if (neighborCell.core) {
                                    const neighborCoreParts = neighborCell.core.split('-');
                                    const neighborPlayer = parseInt(neighborCoreParts[1]);

                                    if (neighborPlayer === attacker) {
                                        surroundCount++;
                                    }
                                }
                            }
                        });

                        // If surrounded by at least 3 attacker cores, mark for elimination
                        if (surroundCount >= 3) {
                            eliminations.push({
                                x,
                                y,
                                core: cell.core,
                                coreType,
                                attacker,
                                defender
                            });
                            break; // Only one attacker can eliminate this core
                        }
                    }
                }
            }

            return eliminations;
        }

        // Apply eliminations
        function applyEliminations(eliminations) {
            eliminations.forEach(elim => {
                // Remove core
                gameState.grid[elim.y][elim.x].core = null;

                // Award points to attacker
                const coreParts = elim.core.split('-');
                const coreType = coreParts[0];

                // 1 point for energy core, 3 for charged
                const points = coreType === 'energy' ? 1 : 3;
                gameState.players[elim.attacker].score += points;
            });

            // Update player cards
            updatePlayerCards();
        }

        // Finish the current turn
        function finishTurn() {
            console.log("\n----- Turn Complete -----");
            logBoardState("Final ");
            console.log(`Charged Cores - P1: [${gameState.players[0].chargedCores.join(',')}] (${gameState.players[0].chargedCores.length}), P2: [${gameState.players[1].chargedCores.join(',')}] (${gameState.players[1].chargedCores.length})`);            console.log("========== TURN END ==========\n");

            if (checkGameEnd()) return; // Check win condition first

            // Increment turn count *within* the round
            gameState.turnInRound++;
            console.log(`Turn ${gameState.turnInRound} of round completed.`);

            // Check if the round has ended
            const totalTurnsPerRound = gameState.turnsPerPlayerPerRound * NUM_PLAYERS;
            if (gameState.turnInRound >= totalTurnsPerRound) {
                console.log("Round ended. Triggering Energy Surge.");
                triggerEnergySurge(); // Call the new surge function
                gameState.turnInRound = 0; // Reset for the next round
            }

            // Switch to next player
            gameState.currentPlayer = 1 - gameState.currentPlayer;
            gameState.turnPhase = 'selecting';
            gameState.anchorCell = null;

            updatePlayerCards(); // Update cards AFTER potential surge
            updateGameStatus(`${gameState.players[gameState.currentPlayer].name}'s turn`);
            updateSurgeCountdown(); // Update the countdown display
            setSelectionMode('energy');
        }

        // *** NEW FUNCTION: Trigger Energy Surge ***
        function triggerEnergySurge() {
            updateGameStatus("Energy Surge!");
            console.log("--- Triggering Energy Surge ---");

            // Increment the VALUE of each stored charged core for both players
            gameState.players.forEach((player, index) => {
                const oldValues = [...player.chargedCores]; // For logging
                // Use map to create a new array with incremented values
                player.chargedCores = player.chargedCores.map(coreValue => coreValue + 1);
                console.log(`Player ${index + 1} cores surged. Values: [${oldValues.join(', ')}] -> [${player.chargedCores.join(', ')}]`);
            });

            // Visual animation
            const surgeOverlay = document.getElementById('surgeOverlay');
            if (surgeOverlay) {
                surgeOverlay.classList.add('active');
                setTimeout(() => surgeOverlay.classList.remove('active'), 900);
            } else {
                console.warn("Surge overlay element not found!");
            }

            // Update player cards AFTER the animation starts
            setTimeout(() => {
                updatePlayerCards(); // Reflect new values
                updateGameStatus(`${gameState.players[gameState.currentPlayer].name}'s turn`); // Reset status after surge
            }, 850);
        }


        // *** NEW FUNCTION: Update Surge Countdown UI ***
        function updateSurgeCountdown() {
            const countdownElement = document.getElementById('surgeCountdown');
            if (countdownElement) {
                const totalTurnsPerRound = gameState.turnsPerPlayerPerRound * NUM_PLAYERS;
                const turnsRemaining = totalTurnsPerRound - gameState.turnInRound;
                countdownElement.textContent = `${turnsRemaining}`;
            } else {
                console.warn("Surge countdown element not found!");
            }
        }


        // Check if the game has ended
        function checkGameEnd() {
            const winner = gameState.players[0].score >= WINNING_SCORE ? 0 :
                gameState.players[1].score >= WINNING_SCORE ? 1 : -1;

            if (winner >= 0) {
                gameState.gameOver = true;
                document.getElementById('gameStatus').textContent = `Game Over! ${gameState.players[winner].name} wins!`;

                // Disable further interactions
                gameState.turnPhase = 'gameover';

                // Add victory animation
                addVictoryAnimation(winner);
                return true;
            }
            return false;
        }

        // Add victory animation
        function addVictoryAnimation(winner) {
            // Add lots of particles in winner's color
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 4;
                const lifespan = 80 + Math.random() * 120;

                particles.push({
                    x,
                    y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 3 + Math.random() * 6,
                    color: PLAYER_COLORS[winner],
                    alpha: 1,
                    life: lifespan,
                    maxLife: lifespan
                });
            }

            // Add victory animation to all cores of the winner
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = gameState.grid[y][x];
                    if (cell.core) {
                        const coreParts = cell.core.split('-');
                        const player = parseInt(coreParts[1]);

                        if (player === winner) {
                            cell.glow = 1; // Start glowing

                            // Add pulse animation
                            animations.push({
                                type: 'victory-pulse',
                                x,
                                y,
                                progress: 0,
                                duration: 30 + Math.floor(Math.random() * 20),
                                player: winner
                            });
                        }
                    }
                }
            }
        }

        // Show help modal
        function showHelpModal() {
            const modal = document.getElementById('helpModal');
            modal.classList.add('visible');
            setTimeout(() => {
                modal.querySelector('.modal-content').style.opacity = 1;
                modal.querySelector('.modal-content').style.transform = 'translateY(0)';
            }, 50);
        }

        // Hide help modal
        function hideHelpModal() {
            const modal = document.getElementById('helpModal');
            const content = modal.querySelector('.modal-content');
            content.style.opacity = 0;
            content.style.transform = 'translateY(20px)';
            setTimeout(() => {
                modal.classList.remove('visible');
            }, 300);
        }

        // Main game loop
        function gameLoop() {
            try {
                update();
                render();
                animationFrameId = requestAnimationFrame(gameLoop);
            } catch (error) {
                console.error("Fatal error in game loop:", error);
                // Try to provide user feedback
                updateGameStatus("Game error occurred. Please refresh the page.", true);
                // Stop the loop to prevent constant errors
                cancelAnimationFrame(animationFrameId);
            }
        }

        // Update game state
        function update() {
            try {
                // Check if game is ready before updating
                if (!gameReadyToRender) {
                    return; // Skip updates until game is ready
                }

                // Update animations
                animations = animations.filter(anim => {
                    anim.progress++;
                    return anim.progress < anim.duration;
                });

                // Update particles
                particles = particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    particle.alpha = particle.life / particle.maxLife;

                    return particle.life > 0;
                });

                // Update cell glow
                if (gameState && gameState.grid) {
                    for (let y = 0; y < GRID_SIZE; y++) {
                        for (let x = 0; x < GRID_SIZE; x++) {
                            const cell = gameState.grid[y][x];
                            if (cell && cell.glow > 0) {
                                cell.glow *= 0.98;
                                if (cell.glow < 0.01) cell.glow = 0;
                            }
                        }
                    }
                }
            } catch (error) {
                console.error("Update error:", error);
            }
        }

        // Render the game with safety checks
        function render() {
            try {
                // First check if game is ready to render
                if (!gameReadyToRender) {
                    console.log("Render called before game was ready, skipping");
                    return;
                }

                // Safety check for canvas context
                if (!ctx) {
                    console.log("Canvas context not available for rendering");
                    return;
                }

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Draw grid background
                drawGridBackground();

                // Draw grid lines
                drawGrid();

                // Safety check for grid before drawing cores
                if (!gameState.grid || !gameState.grid.length) {
                    console.error("Grid not initialized for rendering cores");
                    return;
                }

                // Draw cores and selections
                drawCoresAndSelections();

                // Draw animations
                drawAnimations();

                // Draw particles
                drawParticles();
            } catch (error) {
                console.error("Render error:", error);
            }
        }

        // Draw background pattern
        function drawGridBackground() {
            // Background gradient
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#2a3d45');
            gradient.addColorStop(1, '#253035');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw subtle grid pattern
            ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if ((x + y) % 2 === 0) {
                        ctx.fillRect(
                            x * cellSize,
                            y * cellSize,
                            cellSize,
                            cellSize
                        );
                    }
                }
            }

            // Add subtle glow to the grid edges
            const edgeGlow = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.width / 4,
                canvas.width / 2, canvas.height / 2, canvas.width / 1.5
            );
            edgeGlow.addColorStop(0, 'rgba(255, 255, 255, 0)');
            edgeGlow.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
            ctx.fillStyle = edgeGlow;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Draw the grid
        function drawGrid() {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 1;

            // Draw horizontal lines
            for (let i = 0; i <= GRID_SIZE; i++) {
                const y = i * cellSize;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            // Draw vertical lines
            for (let i = 0; i <= GRID_SIZE; i++) {
                const x = i * cellSize;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
        }

        // Draw Cores and selected cells
        function drawCoresAndSelections() {
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = gameState.grid[y][x];
                    const centerX = x * cellSize + cellSize / 2;
                    const centerY = y * cellSize + cellSize / 2;
                    const radius = cellSize * 0.4;

                    // Draw anchor highlight - only if selected AND anchor
                    if (gameState.anchorCell && gameState.anchorCell.x === x && gameState.anchorCell.y === y && cell.selected) {
                        const pulseTime = Date.now() / 400; // Slightly slower pulse (400)
                        const pulseFactor = Math.sin(pulseTime) * 0.4 + 0.6; //Adjusted range
                        const glowRadius = cellSize * 0.8 * pulseFactor; // Increased glowRadius

                        const grd = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, glowRadius
                        );
                        grd.addColorStop(0, 'rgba(255, 255, 102, 0.7)'); // More opaque yellow
                        grd.addColorStop(0.8, 'rgba(255, 255, 102, 0)');  // More concentrated
                        grd.addColorStop(1, 'rgba(0, 0, 0, 0)');

                        ctx.fillStyle = grd;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, glowRadius, 0, Math.PI * 2); // Draw a circle
                        ctx.fill();
                    }


                    // Draw selection
                    if (cell.selected) {
                        // Highlight background
                        const grd = ctx.createRadialGradient(
                            centerX, centerY, 0,
                            centerX, centerY, cellSize * 0.6
                        );
                        grd.addColorStop(0, PLAYER_GLOW[gameState.currentPlayer]);
                        grd.addColorStop(1, 'rgba(0, 0, 0, 0)');

                        ctx.fillStyle = grd;
                        ctx.fillRect(
                            x * cellSize,
                            y * cellSize,
                            cellSize,
                            cellSize
                        );

                        // REMOVE THIS SECTION
                        // Draw border
                        // ctx.strokeStyle = PLAYER_COLORS[gameState.currentPlayer];
                        // ctx.lineWidth = 2;
                        // ctx.strokeRect(
                        //     x * cellSize + 2,
                        //     y * cellSize + 2,
                        //     cellSize - 4,
                        //     cellSize - 4
                        // );

                        // Draw Core preview
                        ctx.globalAlpha = 0.7;
                        // Find the corresponding selectedCell data to get the preview value
                        const selectedData = gameState.selectedCells.find(s => s.x === x && s.y === y);
                        const previewValue = selectedData ? selectedData.value : 1;
                        drawEnergyCore(centerX, centerY, radius, gameState.currentPlayer, 0, previewValue, selectedData?.type === 'charged'); // Pass value and type
                        ctx.globalAlpha = 1.0;
                    }

                    // Draw Core
                    if (cell.core) {
                        const coreParts = cell.core.split('-');
                        const coreType = coreParts[0];
                        const player = parseInt(coreParts[1]);
                        // Pass the cell's actual value and type to the drawing function
                        drawEnergyCore(centerX, centerY, radius, player, cell.glow, cell.value, coreType === 'charged');
                    }
                }
            }
        }

        // Draw an energy core
        function drawEnergyCore(x, y, radius, player, glow = 0, value = 1, isCharged = false) { // Add value and type params
            // Shadow
            ctx.shadowColor = PLAYER_GLOW[player];
            ctx.shadowBlur = 10 + glow * 20;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Outer circle
            ctx.fillStyle = PLAYER_COLORS[player];
            ctx.beginPath();
            ctx.arc(x, y, radius * (1 + glow * 0.3), 0, Math.PI * 2);
            ctx.fill();

            // Reset shadow
            ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0;

            // Inner design (different for charged potentially)
            if (isCharged) { // Maybe a slightly different inner look for charged?
                ctx.fillStyle = '#dddddd'; // Slightly darker inner for charged
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.7 * (1 + glow * 0.1), 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = PLAYER_COLORS[player]; // Player color center dot
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.3 * (1 + glow * 0.2), 0, Math.PI * 2);
                ctx.fill();
            } else { // Energy core design
                ctx.fillStyle = '#f5f5f5';
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.7 * (1 + glow * 0.1), 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = PLAYER_COLORS[player];
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.4 * (1 + glow * 0.2), 0, Math.PI * 2);
                ctx.fill();
            }

            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(x - radius * 0.2, y - radius * 0.2, radius * 0.15, 0, Math.PI * 2);
            ctx.fill();

            // *** Draw Value if > 1 ***
            if (value > 1) {
                // Optional background for contrast
                // ctx.fillStyle = 'rgba(0,0,0,0.5)';
                // ctx.beginPath();
                // ctx.arc(x + radius * 0.5, y - radius * 0.5, radius * 0.35, 0, Math.PI * 2);
                // ctx.fill();

                ctx.font = `bold ${Math.floor(radius * 0.6)}px Arial`; // Make value prominent
                ctx.fillStyle = 'white'; // White value
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = 'black'; // Add shadow to value text for contrast
                ctx.shadowBlur = 2;
                ctx.fillText(value, x, y); // Center the value on the Core
                ctx.shadowColor = 'transparent'; ctx.shadowBlur = 0; // Reset shadow
            }


            // Glow effect
            if (glow > 0) {
                // ... (glow drawing logic remains the same) ...
                const glowRadius = radius * (1.2 + glow * 0.5);
                const gradient = ctx.createRadialGradient(x, y, radius, x, y, glowRadius);
                gradient.addColorStop(0, PLAYER_GLOW[player]);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.globalAlpha = glow * 0.7;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, glowRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }


        // Draw a charged Core
        function drawChargedCore(x, y, radius, player, glow = 0) {
            // First draw outer glow
            const glowSize = glow * 20;
            const outerGradient = ctx.createRadialGradient(
                x, y, radius,
                x, y, radius * 1.5 + glowSize
            );
            outerGradient.addColorStop(0, PLAYER_GLOW[player]);
            outerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.globalAlpha = 0.7 + glow * 0.3;
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(x, y, radius * 1.5 + glowSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;

            // Shadow
            ctx.shadowColor = PLAYER_GLOW[player];
            ctx.shadowBlur = 15 + glow * 25;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Main circle
            ctx.fillStyle = PLAYER_COLORS[player];
            ctx.beginPath();
            ctx.arc(x, y, radius * (1 + glow * 0.3), 0, Math.PI * 2);
            ctx.fill();

            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;

            // Energy ring
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = radius * 0.15;
            ctx.beginPath();
            ctx.arc(x, y, radius * 0.7, 0, Math.PI * 2);
            ctx.stroke();

            // Lightning bolt
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.lineWidth = radius * 0.15;
            ctx.lineCap = 'round';

            // Draw lightning bolt
            ctx.beginPath();
            ctx.moveTo(x - radius * 0.3, y - radius * 0.4);
            ctx.lineTo(x, y - radius * 0.1);
            ctx.lineTo(x - radius * 0.2, y + radius * 0.4);
            ctx.stroke();

            // Highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(x - radius * 0.3, y - radius * 0.3, radius * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // Add pulsating effect for charged cores
            if (glow === 0) {
                const pulseTime = Date.now() / 1000;
                const pulseFactor = (Math.sin(pulseTime * 3) + 1) * 0.5 * 0.3 + 0.7;

                const pulseGradient = ctx.createRadialGradient(
                    x, y, radius * 0.8 * pulseFactor,
                    x, y, radius * 1.3 * pulseFactor
                );
                pulseGradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
                pulseGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.fillStyle = pulseGradient;
                ctx.beginPath();
                ctx.arc(x, y, radius * 1.3 * pulseFactor, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw particles
        function drawParticles() {
            particles.forEach(particle => {
                ctx.globalAlpha = particle.alpha;
                ctx.fillStyle = particle.color;

                ctx.shadowColor = particle.color;
                ctx.shadowBlur = particle.radius * 2;

                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            });

            ctx.globalAlpha = 1.0;
        }

        // Draw animations (Remove surge case if using DOM animation)
        function drawAnimations() {
            animations.forEach(anim => {
                switch (anim.type) {
                    case 'placement':
                        drawPlacementAnimation(anim);
                        break;
                    case 'fusion':
                        drawFusionAnimation(anim);
                        break;
                    case 'elimination':
                        drawEliminationAnimation(anim);
                        break;
                    case 'victory-pulse':
                        drawVictoryPulseAnimation(anim);
                        break;
                    case 'score-update':
                        drawScoreUpdateAnimation(anim);
                        break;
                    // Remove case 'energy-surge' if using the CSS/DOM approach
                    // case 'energy-surge':
                    //     drawEnergySurgeAnimation(anim); // Keep if you implement a canvas-based surge animation
                    //     break;
                }
            });
        }


        // Draw score update animation
        function drawScoreUpdateAnimation(anim) {
            try {
                const progress = anim.progress / anim.duration;

                // Find the player card
                const playerCard = document.querySelector(`.player${anim.player + 1}`);
                if (!playerCard) return;

                // Get the score display element
                const scoreValue = playerCard.querySelector('.stat-value:first-child');
                if (!scoreValue) return;

                // Get position information
                const rect = scoreValue.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();

                // Calculate position in canvas coordinates
                const x = rect.left + rect.width / 2 - canvasRect.left;
                const y = rect.top + rect.height / 2 - canvasRect.top - (progress * 50);

                // Draw the floating score
                ctx.font = `bold ${Math.floor(24 * (1 - progress))}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = PLAYER_COLORS[anim.player];
                ctx.globalAlpha = 1 - progress;
                ctx.fillText(`+${anim.value}`, x, y);
                ctx.globalAlpha = 1.0;
            } catch (error) {
                console.error("Error drawing score update animation:", error);
            }
        }

        // Draw placement animation
        function drawPlacementAnimation(anim) {
            const centerX = anim.x * cellSize + cellSize / 2;
            const centerY = anim.y * cellSize + cellSize / 2;
            const progress = anim.progress / anim.duration;

            // Scale up from 0 to full size
            const radius = cellSize * 0.4 * Math.min(1, progress * 1.5);

            // Glow effect
            const glowSize = cellSize * 0.6 * (1 - Math.min(1, progress * 2));
            if (glowSize > 0) {
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, radius,
                    centerX, centerY, radius + glowSize
                );
                gradient.addColorStop(0, PLAYER_GLOW[anim.player]);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.globalAlpha = 0.7 * (1 - progress);
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius + glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            // Ripple effect
            if (progress < 0.5) {
                const rippleSize = cellSize * progress * 2;
                ctx.strokeStyle = PLAYER_COLORS[anim.player];
                ctx.lineWidth = 2 * (1 - progress * 2);
                ctx.beginPath();
                ctx.arc(centerX, centerY, rippleSize, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Draw the Core
            drawEnergyCore(centerX, centerY, radius, anim.player);
        }

        // Draw fusion animation
        function drawFusionAnimation(anim) {
            const progress = anim.progress / anim.duration;

            // Calculate center of the fusion
            let centerX = 0, centerY = 0;
            anim.cells.forEach(cell => {
                centerX += cell.x * cellSize + cellSize / 2;
                centerY += cell.y * cellSize + cellSize / 2;
            });
            centerX = centerX / anim.cells.length;
            centerY = centerY / anim.cells.length;

            // First half: converge to center
            if (progress < 0.5) {
                const fadeIn = Math.min(1, progress * 4);

                // Draw connecting energy lines
                ctx.strokeStyle = PLAYER_COLORS[anim.player];
                ctx.lineWidth = cellSize * 0.1 * fadeIn;
                ctx.shadowColor = PLAYER_GLOW[anim.player];
                ctx.shadowBlur = 15;

                anim.cells.forEach(cell => {
                    const cellCenterX = cell.x * cellSize + cellSize / 2;
                    const cellCenterY = cell.y * cellSize + cellSize / 2;

                    // Calculate progress along line
                    const lineX = cellCenterX + (centerX - cellCenterX) * (progress * 2);
                    const lineY = cellCenterY + (centerY - cellCenterY) * (progress * 2);

                    // Draw energy line
                    ctx.beginPath();
                    ctx.moveTo(cellCenterX, cellCenterY);
                    ctx.lineTo(lineX, lineY);
                    ctx.stroke();

                    // Draw energy particles along the line
                    const particleCount = 3;
                    for (let i = 0; i < particleCount; i++) {
                        const t = (progress * 2) * (i / particleCount);
                        const px = cellCenterX + (centerX - cellCenterX) * t;
                        const py = cellCenterY + (centerY - cellCenterY) * t;

                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.beginPath();
                        ctx.arc(px, py, cellSize * 0.05, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });

                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            } else {
                // Second half: explosion
                const explosionProgress = (progress - 0.5) * 2;

                // Draw explosion
                const explosionRadius = cellSize * 1.5 * explosionProgress;
                const gradient = ctx.createRadialGradient(
                    centerX, centerY, 0,
                    centerX, centerY, explosionRadius
                );
                gradient.addColorStop(0, PLAYER_COLORS[anim.player]);
                gradient.addColorStop(0.7, PLAYER_GLOW[anim.player]);
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                ctx.globalAlpha = 1 - explosionProgress;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, explosionRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;

                // Add particles
                if (anim.progress % 3 === 0) {
                    for (let i = 0; i < 5; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = explosionRadius * 0.7;
                        const px = centerX + Math.cos(angle) * distance;
                        const py = centerY + Math.sin(angle) * distance;

                        particles.push({
                            x: px,
                            y: py,
                            vx: Math.cos(angle) * (1 + Math.random() * 2),
                            vy: Math.sin(angle) * (1 + Math.random() * 2),
                            radius: 2 + Math.random() * 4,
                            color: PLAYER_COLORS[anim.player],
                            alpha: 1,
                            life: 20 + Math.random() * 10,
                            maxLife: 30
                        });
                    }
                }

                // Draw new core value at the end
                if (explosionProgress > 0.7) {
                    const valueProgress = (explosionProgress - 0.7) / 0.3;

                    ctx.font = `bold ${Math.floor(cellSize * 0.5 * valueProgress)}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = 'white';
                    ctx.fillText(anim.newValue || "", centerX, centerY);
                }
            }
        }

        // Draw elimination animation
        function drawEliminationAnimation(anim) {
            const progress = anim.progress / anim.duration;
            const centerX = anim.target.x * cellSize + cellSize / 2;
            const centerY = anim.target.y * cellSize + cellSize / 2;

            try {
                // First part: attacker energy effect
                if (progress < 0.7) {
                    const beamProgress = progress / 0.7;

                    ctx.shadowColor = PLAYER_COLORS[anim.attacker];
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = PLAYER_COLORS[anim.attacker];
                    ctx.lineWidth = cellSize * 0.08 * (1 - Math.abs(beamProgress - 0.5) * 2);

                    // Find all adjacent attacker cores
                    const attackerCores = [];

                    // Get adjacent cells to the target
                    const adjacentDirections = [
                        { dx: 1, dy: 0 },   // right
                        { dx: -1, dy: 0 },  // left
                        { dx: 0, dy: 1 },   // down
                        { dx: 0, dy: -1 }   // up
                    ];

                    // Check each adjacent cell for attacker cores
                    adjacentDirections.forEach(dir => {
                        const nx = anim.target.x + dir.dx;
                        const ny = anim.target.y + dir.dy;

                        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                            const adjCell = gameState.grid[ny][nx];
                            if (adjCell.core) {
                                const coreParts = adjCell.core.split('-');
                                const corePlayer = parseInt(coreParts[1]);

                                if (corePlayer === anim.attacker) {
                                    attackerCores.push({ x: nx, y: ny });
                                }
                            }
                        }
                    });

                    // Draw beams from attacker cores to the target
                    attackerCores.forEach(attacker => {
                        const attackerX = attacker.x * cellSize + cellSize / 2;
                        const attackerY = attacker.y * cellSize + cellSize / 2;

                        // Draw beam
                        ctx.beginPath();
                        ctx.moveTo(attackerX, attackerY);
                        ctx.lineTo(centerX, centerY);
                        ctx.stroke();

                        // Draw energy particles along the beam
                        const particleCount = 4;
                        for (let i = 0; i < particleCount; i++) {
                            // Oscillate particle position
                            const oscillation = Math.sin((beamProgress * 10) + (i / particleCount * Math.PI * 2));
                            const t = beamProgress * (i / particleCount) + oscillation * 0.05;
                            const px = attackerX + (centerX - attackerX) * t;
                            const py = attackerY + (centerY - attackerY) * t;

                            ctx.fillStyle = 'white';
                            ctx.beginPath();
                            ctx.arc(px, py, cellSize * 0.04, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    });

                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;

                    // Draw target core with increasing glow/shake
                    const coreParts = anim.core.split('-');
                    const coreType = coreParts[0];
                    const player = parseInt(coreParts[1]);

                    // Calculate shake offset
                    const shakeAmount = beamProgress * 3;
                    const offsetX = (Math.random() * 2 - 1) * shakeAmount;
                    const offsetY = (Math.random() * 2 - 1) * shakeAmount;

                    // Draw with increasing glow
                    drawEnergyCore(centerX + offsetX, centerY + offsetY, cellSize * 0.4, player, beamProgress);
                } else {
                    // Explosion effect for the elimination
                    const explosionProgress = (progress - 0.7) / 0.3;

                    // Draw explosion
                    const explosionRadius = cellSize * explosionProgress;
                    const gradient = ctx.createRadialGradient(
                        centerX, centerY, 0,
                        centerX, centerY, explosionRadius
                    );
                    gradient.addColorStop(0, 'white');
                    gradient.addColorStop(0.3, PLAYER_COLORS[anim.attacker]);
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.globalAlpha = 1 - explosionProgress * 0.5;
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, explosionRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;

                    // Create explosion particles
                    if (anim.progress % 2 === 0 && explosionProgress < 0.5) {
                        for (let i = 0; i < 3; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const speed = 1 + Math.random() * 3;

                            particles.push({
                                x: centerX,
                                y: centerY,
                                vx: Math.cos(angle) * speed,
                                vy: Math.sin(angle) * speed,
                                radius: 3 + Math.random() * 4,
                                color: PLAYER_COLORS[anim.defender], // Use defender's color for the particles
                                alpha: 1,
                                life: 20 + Math.random() * 10,
                                maxLife: 30
                            });
                        }
                    }

                    // Draw "Returned" indicator at the end
                    if (explosionProgress > 0.6) {
                        const textProgress = (explosionProgress - 0.6) / 0.4;

                        ctx.font = `bold ${Math.floor(cellSize * 0.3 * textProgress)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = PLAYER_COLORS[anim.defender];
                        ctx.fillText("Returned", centerX, centerY - cellSize * 0.3 * textProgress);
                    }
                }
            } catch (error) {
                console.error("Error drawing elimination animation:", error);
            }
        }

        // Draw victory pulse animation for winner's Cores
        function drawVictoryPulseAnimation(anim) {
            const progress = anim.progress / anim.duration;
            const x = anim.x * cellSize + cellSize / 2;
            const y = anim.y * cellSize + cellSize / 2;

            // Pulse glow around the Core
            const pulseSize = cellSize * 0.6 * Math.sin(progress * Math.PI);

            const gradient = ctx.createRadialGradient(
                x, y, cellSize * 0.4,
                x, y, cellSize * 0.4 + pulseSize
            );
            gradient.addColorStop(0, PLAYER_GLOW[anim.player]);
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

            ctx.globalAlpha = 0.7 * (1 - progress);
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, cellSize * 0.4 + pulseSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;

            // Add particles at peak
            if (progress > 0.45 && progress < 0.55 && anim.progress % 3 === 0) {
                for (let i = 0; i < 2; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = cellSize * 0.5;

                    particles.push({
                        x: x + Math.cos(angle) * distance,
                        y: y + Math.sin(angle) * distance,
                        vx: Math.cos(angle) * 1,
                        vy: Math.sin(angle) * 1,
                        radius: 2 + Math.random() * 2,
                        color: PLAYER_COLORS[anim.player],
                        alpha: 0.7,
                        life: 15 + Math.random() * 10,
                        maxLife: 25
                    });
                }
            }

            // Update cell glow for victory effect
            if (progress > 0.8) {
                gameState.grid[anim.y][anim.x].glow = 0.8;
            }
        }

        // Initialize game when DOM is fully loaded
        function init() {
            console.log("Starting initialization...");

            try {
                // Safety check - don't initialize multiple times
                if (window.gameInitialized) {
                    console.log("Game already initialized, skipping");
                    return;
                }

                window.gameInitialized = true;
                console.log("Game initialization flag set");

                // Initialize grid first to ensure it's ready
                initGrid();
                console.log("Grid initialized FIRST in the sequence");

                // Get canvas explicitly
                canvas = document.getElementById('gameCanvas');

                if (!canvas) {
                    console.error("Could not find the gameCanvas element!");
                    alert("Error: Could not find the game canvas. Please refresh the page.");
                    return;
                }

                // Get context
                ctx = canvas.getContext('2d');

                if (!ctx) {
                    console.error("Could not get 2D context from canvas!");
                    alert("Error: Could not initialize the game canvas. Please try a different browser.");
                    return;
                }

                console.log("Canvas and context obtained successfully");

                // Set up player cards first before any rendering
                createPlayerCards();
                console.log("Player cards created successfully");

                // Resize canvas (but don't render yet)
                resizeCanvasWithoutRendering();
                console.log("Canvas resized without rendering");

                // Set up all event listeners directly
                setupEventListeners();

                // Now set the ready flag
                gameReadyToRender = true;
                console.log("Game ready to render flag set");

                // Start the game loop only when everything is ready
                gameLoop();

                console.log("Game initialization complete");
            } catch (error) {
                console.error("Initialization error:", error);
                alert("Game initialization failed. Please reload the page.");
            }
        }

        // Separate function to set up all event listeners
        function setupEventListeners() {
            try {
                // Add canvas click listener
                if (canvas) {
                    canvas.onclick = handleCanvasClick;
                    console.log("Canvas click listener attached");
                }

                // Setup End Turn button
                const endTurnBtn = document.getElementById('endTurnBtn');
                if (endTurnBtn) {
                    endTurnBtn.onclick = function () {
                        console.log("End turn button clicked");
                        endTurn();
                    };
                    console.log("End turn button listener attached");
                }

                // Help button
                const helpBtn = document.getElementById('helpBtn');
                if (helpBtn) {
                    helpBtn.onclick = function () {
                        console.log("Help button clicked");
                        showHelpModal();
                    };
                    console.log("Help button listener attached");
                }

                // Close modal button
                const closeModalBtn = document.getElementById('closeModal');
                if (closeModalBtn) {
                    closeModalBtn.onclick = function () {
                        console.log("Close modal button clicked");
                        hideHelpModal();
                    };
                    console.log("Close modal button listener attached");
                }

                // Hook up event listeners in the setupEventListeners function
                // Settings button
                const settingsBtn = document.getElementById('settingsBtn');
                if (settingsBtn) {
                    settingsBtn.onclick = function () {
                        console.log("Settings button clicked");
                        showSettingsModal();
                    };
                    console.log("Settings button listener attached");
                }

                // Close settings modal button
                const closeSettingsModalBtn = document.getElementById('closeSettingsModal');
                if (closeSettingsModalBtn) {
                    closeSettingsModalBtn.onclick = function () {
                        console.log("Close settings modal button clicked");
                        hideSettingsModal();
                    };
                    console.log("Close settings modal button listener attached");
                }

                // Apply settings button
                const applySettingsBtn = document.getElementById('applySettingsBtn');
                if (applySettingsBtn) {
                    applySettingsBtn.onclick = function () {
                        console.log("Apply settings button clicked");
                        applySettingsAndNewGame();
                    };
                    console.log("Apply settings button listener attached");
                }

                // Window resize listener
                window.addEventListener('resize', resizeCanvas);

                console.log("All event listeners attached successfully");
            } catch (error) {
                console.error("Error setting up event listeners:", error);
            }
        }

        // Resize canvas without triggering render
        function resizeCanvasWithoutRendering() {
            try {
                const container = canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight);
                canvas.width = size;
                canvas.height = size;
                cellSize = size / GRID_SIZE;

                console.log(`Canvas resized to ${size}x${size}, cell size: ${cellSize}`);
            } catch (error) {
                console.error("Error resizing canvas:", error);
            }
        }

        // Use both initialization methods with window.onload as primary for full reliability
        window.onload = init;

        // Helper function to log board state
        function logBoardState(prefix = "") {
            console.log(`\n${prefix}Board State:`);
            for (let y = 0; y < GRID_SIZE; y++) {
                let row = "";
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = gameState.grid[y][x];
                    if (!cell.core) {
                        row += "[ ] ";
                    } else {
                        const coreParts = cell.core.split('-');
                        const type = coreParts[0][0].toUpperCase(); // E for energy, C for charged
                        const player = parseInt(coreParts[1]) + 1;  // Convert to 1-based for readability
                        const value = cell.value || (type === 'E' ? 1 : 2);
                        row += `[${type}${player}:${value}] `;
                    }
                }
                console.log(row);
            }
            console.log("\n");
        }
    </script>
</body>

</html>