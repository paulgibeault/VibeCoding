<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Energy Grid Game</title>
    <style>
        /* Mid-century modern inspired design with energy theme */
        :root {
            --primary-color: #FF5A5F;
            --secondary-color: #3ECDC1;
            --tertiary-color: #FFC857;
            --background-color: #2A3D45;
            --grid-color: #3F4E4F;
            --text-color: #EFF6E0;
            --player1-color: #FF5A5F;
            --player2-color: #3ECDC1;
            --player1-glow: rgba(255, 90, 95, 0.6);
            --player2-glow: rgba(62, 205, 193, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .game-container {
            max-width: 1200px;
            width: 100%;
            background: radial-gradient(circle at center, #3a4e56, #23353B);
            border-radius: 15px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            position: relative;
        }

        .game-header {
            background: linear-gradient(135deg, var(--primary-color), #8a3236);
            padding: 20px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .game-header::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.05),
                rgba(255, 255, 255, 0.05) 10px,
                rgba(255, 255, 255, 0) 10px,
                rgba(255, 255, 255, 0) 20px
            );
        }

        .game-header h1 {
            font-weight: 700;
            letter-spacing: 3px;
            font-size: 2.8rem;
            margin-bottom: 5px;
            position: relative;
            text-shadow: 3px 3px 0px rgba(0, 0, 0, 0.2);
        }

        .game-header p {
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
            font-weight: 300;
        }

        .game-content {
            display: flex;
            flex-direction: column;
            padding: 25px;
            position: relative;
            z-index: 1;
        }

        /* Player cards */
        .player-cards {
            display: flex;
            justify-content: space-around;
            width: 100%;
            margin-bottom: 30px;
            gap: 20px;
        }

        .player-card {
            background: rgba(42, 61, 69, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            width: 45%;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .player-card.active {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.3);
        }

        .player-card.player1 {
            background: linear-gradient(45deg, rgba(68, 41, 41, 0.7), rgba(58, 35, 35, 0.7));
            border-left: 5px solid var(--player1-color);
        }

        .player-card.player2 {
            background: linear-gradient(45deg, rgba(34, 65, 63, 0.7), rgba(25, 53, 51, 0.7));
            border-left: 5px solid var(--secondary-color);
        }

        .player-card.active::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, 
                rgba(255,255,255,0) 0%, 
                rgba(255,255,255,0.1) 50%, 
                rgba(255,255,255,0) 100%);
            animation: shine 2s infinite;
        }

        @keyframes shine {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .turn-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .player1.active .turn-indicator {
            background: radial-gradient(circle at center, var(--player1-color), #8a3236);
            box-shadow: 0 0 15px 5px var(--player1-glow);
            opacity: 1;
            animation: pulse 1.5s infinite;
        }

        .player2.active .turn-indicator {
            background: radial-gradient(circle at center, var(--secondary-color), #27918a);
            box-shadow: 0 0 15px 5px var(--player2-glow);
            opacity: 1;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(0.8); box-shadow: 0 0 15px 2px var(--player1-glow); }
            50% { transform: scale(1.2); box-shadow: 0 0 25px 5px var(--player1-glow); }
            100% { transform: scale(0.8); box-shadow: 0 0 15px 2px var(--player1-glow); }
        }

        .player-name {
            font-size: 1.6rem;
            margin-bottom: 20px;
            position: relative;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .player1 .player-name {
            color: var(--player1-color);
            text-shadow: 0 0 10px rgba(255, 90, 95, 0.5);
        }

        .player2 .player-name {
            color: var(--secondary-color);
            text-shadow: 0 0 10px rgba(62, 205, 193, 0.5);
        }

        .player-stats {
            display: flex;
            justify-content: space-between;
        }

        .stat {
            text-align: center;
            flex: 1;
            position: relative;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin: 0 5px;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            line-height: 1;
            margin-bottom: 8px;
            position: relative;
        }

        .player1 .stat-value {
            color: var(--player1-color);
            text-shadow: 0 0 8px rgba(255, 90, 95, 0.5);
        }

        .player2 .stat-value {
            color: var(--secondary-color);
            text-shadow: 0 0 8px rgba(62, 205, 193, 0.5);
        }

        .stat-label {
            font-size: 0.9rem;
            text-transform: uppercase;
            color: #CCC;
            letter-spacing: 1px;
            font-weight: 300;
        }

        /* Game board */
        .game-board-container {
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 20px 0;
            position: relative;
        }

        .game-board {
            width: min(600px, 100%);
            aspect-ratio: 1 / 1;
            border-radius: 15px;
            overflow: hidden;
            background-color: var(--grid-color);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.4), 
                        inset 0 0 20px rgba(0, 0, 0, 0.6);
            position: relative;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        /* Game controls */
        .game-controls {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 30px;
            flex-wrap: wrap;
        }

        .token-selection {
            display: flex;
            gap: 15px;
        }

        .token-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid var(--tertiary-color);
            color: var(--tertiary-color);
            padding: 12px 24px;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .token-btn:hover {
            background-color: rgba(255, 200, 87, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
        }

        .token-btn.active {
            background-color: var(--tertiary-color);
            color: var(--background-color);
            box-shadow: 0 0 15px rgba(255, 200, 87, 0.5);
        }

        .token-btn::after {
            content: "";
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: -100%;
            background: linear-gradient(90deg, 
                rgba(255,255,255,0) 0%, 
                rgba(255,255,255,0.2) 50%, 
                rgba(255,255,255,0) 100%);
            transition: transform 0.5s ease;
        }

        .token-btn:hover::after {
            left: 100%;
            transition: 0.5s ease;
        }

        .end-turn-btn {
            background: linear-gradient(45deg, var(--primary-color), #d63d42);
            color: white;
            padding: 12px 36px;
            border: none;
            border-radius: 30px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        .end-turn-btn:hover {
            background: linear-gradient(45deg, #FF7175, #c83639);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
        }

        .end-turn-btn::after {
            content: "";
            position: absolute;
            width: 30px;
            height: 100%;
            top: 0;
            left: -100px;
            background: linear-gradient(
                90deg,
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.4) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            animation: btnShine 3s infinite;
        }

        @keyframes btnShine {
            0% { left: -100px; }
            20% { left: 100%; }
            100% { left: 100%; }
        }

        /* Game info */
        .game-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .turn-info, .game-status {
            font-size: 1.1rem;
            font-weight: 300;
        }

        .help-btn {
            background-color: var(--tertiary-color);
            color: var(--background-color);
            border: none;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }

        .help-btn:hover {
            background-color: #e9b849;
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3);
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal.visible {
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 1;
        }

        .modal-content {
            background: radial-gradient(circle at center, #3a4e56, #23353B);
            margin: 10% auto;
            padding: 30px;
            width: 80%;
            max-width: 600px;
            border-radius: 15px;
            box-shadow: 0 5px 30px rgba(0, 0, 0, 0.5);
            max-height: 80vh;
            overflow-y: auto;
            transform: translateY(20px);
            opacity: 0;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-color);
        }

        .modal.visible .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .modal-close:hover {
            color: #fff;
        }

        .modal-title {
            margin-bottom: 20px;
            color: var(--tertiary-color);
            font-size: 1.8rem;
            border-bottom: 2px solid rgba(255, 200, 87, 0.3);
            padding-bottom: 10px;
        }

        .modal-body h3 {
            margin-top: 20px;
            margin-bottom: 10px;
            color: var(--secondary-color);
        }

        .modal-body p, .modal-body li {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .modal-body ul, .modal-body ol {
            margin-left: 20px;
            margin-bottom: 15px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .player-cards {
                flex-direction: column;
            }
            
            .player-card {
                width: 100%;
                margin-bottom: 15px;
            }
            
            .game-controls {
                flex-direction: column;
                gap: 15px;
            }
            
            .token-selection {
                width: 100%;
                justify-content: center;
            }
            
            .end-turn-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <h1>ENERGY GRID</h1>
            <p>A strategic battle of energy cores and fusion reactions</p>
        </div>
        
        <div class="game-content">
            <div class="player-cards">
                <!-- Player cards will be dynamically generated here -->
            </div>
            
            <div class="game-board-container">
                <div class="game-board">
                    <canvas id="gameCanvas"></canvas>
                </div>
            </div>
            
        <div class="game-controls">
                <button id="endTurnBtn" class="end-turn-btn">End Turn</button>
            </div>
        </div>
        
        <div class="game-info">
            <div class="turn-info">
                <p>Current Turn: <span id="currentPlayer">Player 1</span></p>
            </div>
            <div class="game-status">
                <p id="gameStatus">Game in progress...</p>
            </div>
            <button class="help-btn" id="helpBtn">How to Play</button>
        </div>
    </div>

    <div class="modal" id="helpModal">
        <div class="modal-content">
            <span class="modal-close" id="closeModal">&times;</span>
            <h2 class="modal-title">How to Play Energy Grid</h2>
            <div class="modal-body">
                <h3>Game Objective</h3>
                <p>Score the most points by creating fusions and eliminating opponent cores.</p>
                
                <h3>Turn Structure</h3>
                <ol>
                    <li>Your first placed core each turn is automatically an Energy Core</li>
                    <li>Any additional cores placed are Charged Cores (using your available supply)</li>
                    <li>Click "End Turn" to confirm placement</li>
                </ol>
                
                <h3>Placing Cores</h3>
                <p>Click on empty grid cells to select them for placement. Click again to deselect. Cores are placed at the end of your turn.</p>
                
                <h3>Core Interactions</h3>
                <p><strong>Fusion (Same Cores):</strong> When two of your cores are adjacent (horizontally or vertically), they fuse into a single core at the placement location. The value of the new core is the sum of the fused cores.</p>
                <p><strong>Elimination (Different Cores):</strong> When a core is adjacent to an opponent's core of lower value, the opponent's core is eliminated and returned to their owner as a charged core.</p>
                
                <h3>Scoring</h3>
                <ul>
                    <li>Score increases by the sum of eliminated cores' values.</li>
                </ul>
                
                <h3>Charged Cores</h3>
                <ul>
                    <li>Players start with 0 charged cores.</li>
                    <li>Placing a charged core decreases your charged core count by 1.</li>
                    <li>When your cores are eliminated, they are returned to you as charged cores.</li>
                </ul>
                
                <h3>Game End</h3>
                <p>The game ends when a player reaches 20 points.</p>
            </div>
        </div>
    </div>
    
    <script>
        "use strict"; // Enable strict mode for better error detection
        
        console.log("Script loading");
    
        // Game constants
        const GRID_SIZE = 8;
        const PLAYER_COLORS = ['#FF5A5F', '#3ECDC1']; // Player 1, Player 2
        const PLAYER_GLOW = ['rgba(255, 90, 95, 0.7)', 'rgba(62, 205, 193, 0.7)']; // Player 1, Player 2 glow
        const PLAYER_NAMES = ['Player 1', 'Player 2'];
        const WINNING_SCORE = 20;

        // Game state
        let gameState = {
            currentPlayer: 0, // 0 or 1
            players: [
                { name: PLAYER_NAMES[0], score: 0, chargedTokens: 0 }, // Changed to 0
                { name: PLAYER_NAMES[1], score: 0, chargedTokens: 0 }  // Changed to 0
            ],
            grid: [], // Will be initialized as 2D array
            selectedCells: [], // Cells selected for token placement
            selectionMode: 'energy', // 'energy' or 'charged'
            turnPhase: 'selecting', // 'selecting' or 'animation'
            placedEnergyToken: false, // Flag to track if energy token has been placed
            gameOver: false
        };

        // Canvas and rendering variables
        let canvas, ctx;
        let cellSize;
        let animationFrameId;
        let animations = [];
        let particles = []; // For particle effects
        
        // Critical flag to prevent rendering before initialization is complete
        let gameReadyToRender = false;
        
        // Debug mode
        const DEBUG = true;
        
        function debug(message) {
            if (DEBUG) {
                console.log(message);
                // Safely try to update game status
                try {
                    const statusElement = document.getElementById('gameStatus');
                    if (statusElement) {
                        statusElement.textContent = message;
                    }
                } catch (e) {
                    console.log("Could not update status element: " + e.message);
                }
            }
        }
        
        // Global helper to directly update game status for critical messages
        function updateGameStatus(message, isError = false) {
            console.log(message);
            
            try {
                const statusElement = document.getElementById('gameStatus');
                if (statusElement) {
                    statusElement.textContent = message;
                    
                    if (isError) {
                        statusElement.style.color = 'red';
                        setTimeout(() => {
                            statusElement.style.color = ''; // Reset color after 3 seconds
                        }, 3000);
                    }
                }
            } catch (e) {
                console.error("Failed to update status:", e);
            }
        }
        
        // This function is now unused as we're initializing directly in init()
        function initGame() {
            console.log("initGame function called - but using direct initialization instead");
        }

        // Initialize the grid with empty cells
        function initGrid() {
            debug("Initializing grid");
            gameState.grid = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                let row = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    row.push({
                        x,
                        y,
                        token: null, // null, 'energy-0', 'energy-1', 'charged-0', 'charged-1'
                        selected: false,
                        animation: null,
                        glow: 0 // For highlighting effects
                    });
                }
                gameState.grid.push(row);
            }
            debug(`Grid initialized with size ${GRID_SIZE}x${GRID_SIZE}`);
        }

        // Resize canvas to maintain aspect ratio
        function resizeCanvas() {
            try {
                const container = canvas.parentElement;
                const size = Math.min(container.clientWidth, container.clientHeight);
                canvas.width = size;
                canvas.height = size;
                cellSize = size / GRID_SIZE;
                
                debug(`Canvas resized to ${size}x${size}, cell size: ${cellSize}`);
                
                // Re-render after resize
                render();
            } catch (error) {
                debug("Error resizing canvas: " + error.message);
                console.error(error);
            }
        }

        // Create player cards in the DOM
        function createPlayerCards() {
            console.log("Creating player cards");
            
            const playerCardsContainer = document.querySelector('.player-cards');
            
            if (!playerCardsContainer) {
                console.error("Player cards container not found!");
                return;
            }
            
            playerCardsContainer.innerHTML = '';
            
            console.log("Player cards container found, creating cards");
            
            gameState.players.forEach((player, index) => {
                const playerCard = document.createElement('div');
                playerCard.className = `player-card player${index + 1}`;
                if (index === gameState.currentPlayer) {
                    playerCard.classList.add('active');
                }
                
                playerCard.innerHTML = `
                    <div class="turn-indicator"></div>
                    <h2 class="player-name">${player.name}</h2>
                    <div class="player-stats">
                        <div class="stat">
                            <div class="stat-value">${player.score}</div>
                            <div class="stat-label">Score</div>
                        </div>
                        <div class="stat">
                            <div class="stat-value">${player.chargedTokens}</div>
                            <div class="stat-label">Charged</div>
                        </div>
                    </div>
                `;
                
                playerCardsContainer.appendChild(playerCard);
                console.log(`Player ${index + 1} card created`);
            });
            
            console.log("All player cards created successfully");
        }

        // Update player cards with current game state
        function updatePlayerCards() {
            try {
                console.log("Updating player cards");
                
                const playerCards = document.querySelectorAll('.player-card');
                
                if (!playerCards || playerCards.length === 0) {
                    console.error("No player cards found to update!");
                    return;
                }
                
                console.log(`Found ${playerCards.length} player cards to update`);
                
                // Log current player state for debugging
                gameState.players.forEach((player, idx) => {
                    console.log(`Player ${idx + 1}: Score=${player.score}, ChargedTokens=${player.chargedTokens}`);
                });
                
                playerCards.forEach((card, index) => {
                    try {
                        // Update active class
                        if (index === gameState.currentPlayer && !gameState.gameOver) {
                            card.classList.add('active');
                        } else {
                            card.classList.remove('active');
                        }
                        
                        // Update values
                        const scoreValue = card.querySelector('.stat-value:first-child');
                        const chargedValue = card.querySelector('.stat-value:last-child');
                        
                        if (scoreValue) {
                            scoreValue.textContent = gameState.players[index].score;
                        }
                        
                        if (chargedValue) {
                            chargedValue.textContent = gameState.players[index].chargedTokens;
                        }
                    } catch (err) {
                        console.error(`Error updating player card ${index}:`, err);
                    }
                });
                
                // Update current player display
                const currentPlayerElement = document.getElementById('currentPlayer');
                if (currentPlayerElement) {
                    currentPlayerElement.textContent = gameState.players[gameState.currentPlayer].name;
                }
                
                console.log("Player cards updated successfully");
            } catch (error) {
                console.error("Error updating player cards:", error);
            }
        }

        // Set the current selection mode
        function setSelectionMode(mode) {
            console.log(`Selection mode change requested: ${mode}`);
            
            // Don't allow changing if game is over
            if (gameState.gameOver) {
                console.log("Game is over, ignoring selection mode change");
                return;
            }
            
            // Don't switch to charged if player has no charged tokens
            if (mode === 'charged' && gameState.players[gameState.currentPlayer].chargedTokens <= 0) {
                console.log("Player has no charged tokens available");
                updateGameStatus("No charged cores available!", true);
                setTimeout(() => {
                    updateGameStatus("Game in progress...");
                }, 2000);
                return;
            }
            
            gameState.selectionMode = mode;
            console.log(`Selection mode changed to: ${mode}`);
            updateGameStatus(`Selected ${mode} core placement mode`);
            
            try {
                // Update UI to reflect current mode
                const energyBtn = document.getElementById('energyTokenBtn');
                const chargedBtn = document.getElementById('chargedTokenBtn');
                
                if (!energyBtn || !chargedBtn) {
                    console.error("Energy or charged button not found in the DOM");
                    return;
                }
                
                if (mode === 'energy') {
                    energyBtn.classList.add('active');
                    chargedBtn.classList.remove('active');
                } else {
                    energyBtn.classList.remove('active');
                    chargedBtn.classList.add('active');
                }
                
                console.log("Button UI updated successfully");
            } catch (error) {
                console.error("Error updating selection mode UI:", error);
            }
        }

        // Handle canvas click events
        function handleCanvasClick(event) {
            console.log("Canvas clicked");
            updateGameStatus("Canvas clicked, processing selection...");
            
            // Safety checks
            if (!gameReadyToRender) {
                console.log("Game not ready for interaction");
                updateGameStatus("Game still initializing...");
                return;
            }
            
            if (gameState.turnPhase !== 'selecting' || gameState.gameOver) {
                console.log("Turn phase or game state prevents selection");
                updateGameStatus(gameState.gameOver ? "Game is over!" : "Cannot select during animations");
                return;
            }
            
            // Get grid coordinates from click position
            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;
            
            console.log(`Click position: (${clickX}, ${clickY}), Cell size: ${cellSize}`);
            
            const x = Math.floor(clickX / cellSize);
            const y = Math.floor(clickY / cellSize);
            
            console.log(`Grid position: (${x}, ${y})`);
            
            // Check if click is within grid
            if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                try {
                    const cell = gameState.grid[y][x];
                    if (!cell) {
                        console.error(`Cell at (${x}, ${y}) is undefined!`);
                        return;
                    }
                    
                    console.log(`Cell at (${x}, ${y}): ${cell.token ? 'occupied' : 'empty'}, selected: ${cell.selected}`);
                    
                    // Toggle selection
                    if (cell.selected) {
                        console.log("Deselecting cell");
                        updateGameStatus("Cell deselected");
                        
                        // Deselect
                        cell.selected = false;
                        
                        // Find and remove from selectedCells
                        const index = gameState.selectedCells.findIndex(
                            selected => selected.x === x && selected.y === y
                        );
                        
                        if (index !== -1) {
                            // If deselecting an energy token, update the flag
                            if (gameState.selectedCells[index].type === 'energy') {
                                gameState.placedEnergyToken = false;
                                console.log("Energy token deselected");
                            }
                            
                            gameState.selectedCells.splice(index, 1);
                        }
                    } else if (!cell.token) {
                        // Select only if cell is empty
                        console.log("Selecting empty cell");
                        
                        // Check if exceeding max selections (1 + charged core count)
                        const maxSelections = 1 + gameState.players[gameState.currentPlayer].chargedTokens;
                        if (gameState.selectedCells.length >= maxSelections) {
                            console.log(`Cannot select more than ${maxSelections} cells`);
                            updateGameStatus(`Cannot place more than ${maxSelections} cores in one turn!`, true);
                            setTimeout(() => {
                                updateGameStatus("Game in progress...");
                            }, 2000);
                            return;
                        }
                        
                        // Determine token type based on selection count
                        // First cell is energy, rest are charged
                        const tokenType = gameState.selectedCells.length === 0 ? 'energy' : 'charged';
                        
                        // If trying to place a charged token when none are available
                        if (tokenType === 'charged' && gameState.players[gameState.currentPlayer].chargedTokens === 0) {
                            console.log("No charged cores available");
                            updateGameStatus("No charged cores available!", true);
                            setTimeout(() => {
                                updateGameStatus("Game in progress...");
                            }, 2000);
                            return;
                        }
                        
                        // Update energy token placement flag
                        if (tokenType === 'energy') {
                            gameState.placedEnergyToken = true;
                            console.log("Energy token selected");
                            updateGameStatus("Energy core selected");
                        } else {
                            console.log("Charged token selected");
                            updateGameStatus("Charged core selected");
                        }
                        
                        cell.selected = true;
                        gameState.selectedCells.push({ x, y, type: tokenType });
                        
                        console.log(`Cell selected: (${x}, ${y}), type: ${tokenType}`);
                        
                        // Add selection particles
                        addSelectionParticles(x, y);
                    } else {
                        updateGameStatus("Cell already occupied");
                    }
                    
                    // Force re-render
                    render();
                } catch (error) {
                    console.error("Error handling grid click:", error);
                    updateGameStatus("Error processing selection", true);
                }
            } else {
                console.log("Click outside grid bounds");
                updateGameStatus("Click outside grid bounds");
            }
        }

        // Add particles for selection feedback
        function addSelectionParticles(x, y) {
            const centerX = x * cellSize + cellSize / 2;
            const centerY = y * cellSize + cellSize / 2;
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const speed = 1 + Math.random() * 2;
                const lifespan = 30 + Math.random() * 20;
                
                particles.push({
                    x: centerX,
                    y: centerY,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 2 + Math.random() * 3,
                    color: PLAYER_COLORS[gameState.currentPlayer],
                    alpha: 1,
                    life: lifespan,
                    maxLife: lifespan
                });
            }
        }

        // End the current turn
        function endTurn() {
            console.log("End turn requested");
            
            if (!gameReadyToRender) {
                console.log("Game not ready for turn end");
                updateGameStatus("Game still initializing...");
                return;
            }
            
            if (gameState.turnPhase !== 'selecting' || gameState.gameOver) {
                console.log("Cannot end turn: incorrect phase or game over");
                updateGameStatus(gameState.gameOver ? "Game is over!" : "Cannot end turn during animations");
                return;
            }
            
            // Verify placed an energy token
            if (!gameState.placedEnergyToken) {
                console.log("No energy token placed");
                updateGameStatus("You must place one energy core!", true);
                setTimeout(() => {
                    updateGameStatus("Game in progress...");
                }, 2000);
                return;
            }
            
            // Verify player has enough charged tokens
            const chargedCount = gameState.selectedCells.filter(cell => cell.type === 'charged').length;
            if (chargedCount > gameState.players[gameState.currentPlayer].chargedTokens) {
                console.log("Not enough charged tokens");
                updateGameStatus("Not enough charged cores!", true);
                setTimeout(() => {
                    updateGameStatus("Game in progress...");
                }, 2000);
                return;
            }
            
            // Verify not exceeding max selections
            const maxSelections = 1 + gameState.players[gameState.currentPlayer].chargedTokens;
            if (gameState.selectedCells.length > maxSelections) {
                console.log(`Too many selections: ${gameState.selectedCells.length} > ${maxSelections}`);
                updateGameStatus(`Cannot place more than ${maxSelections} cores in one turn!`, true);
                setTimeout(() => {
                    updateGameStatus("Game in progress...");
                }, 2000);
                return;
            }
            
            try {
                // Change phase to animation
                gameState.turnPhase = 'animation';
                console.log("Turn phase changed to animation");
                updateGameStatus("Processing turn...");
                
                // Modify player's charged core count BEFORE placing tokens
                if (chargedCount > 0) {
                    console.log(`Player ${gameState.currentPlayer + 1} has ${gameState.players[gameState.currentPlayer].chargedTokens} charged cores before placement`);
                    
                    // Decrease player's charged core count
                    gameState.players[gameState.currentPlayer].chargedTokens -= chargedCount;
                    
                    console.log(`Player ${gameState.currentPlayer + 1} used ${chargedCount} charged cores`);
                    console.log(`Player ${gameState.currentPlayer + 1} now has ${gameState.players[gameState.currentPlayer].chargedTokens} charged cores`);
                    
                    // Update player cards immediately to reflect the change
                    updatePlayerCards();
                }
                
                // Place tokens on the grid
                placeTokens();
                console.log("Tokens placed on grid");
                
                // Reset energy token flag for next turn
                gameState.placedEnergyToken = false;
                
                // Check for fusions and eliminations
                console.log("Scheduling core interactions processing");
                setTimeout(() => {
                    processCoreInteractions();
                }, 600);
            } catch (error) {
                console.error("Error ending turn:", error);
                gameState.turnPhase = 'selecting'; // Reset phase on error
                updateGameStatus("Error processing turn", true);
            }
        }

        // Place tokens on the grid
        function placeTokens() {
            try {
                console.log(`Placing ${gameState.selectedCells.length} tokens on the grid`);
                
                // Keep track of all newly placed tokens
                const placedPositions = [];
                
                gameState.selectedCells.forEach(selected => {
                    const { x, y, type } = selected;
                    
                    // Set token with initial value (energy=1, charged=2)
                    gameState.grid[y][x].token = `${type}-${gameState.currentPlayer}`;
                    gameState.grid[y][x].value = type === 'energy' ? 1 : 2;
                    gameState.grid[y][x].selected = false;
                    gameState.grid[y][x].justPlaced = true; // Mark as just placed for interaction detection
                    
                    placedPositions.push({ x, y });
                    
                    console.log(`Placed ${type} token at (${x}, ${y}) with value ${gameState.grid[y][x].value}`);
                    
                    // Add placement animation
                    animations.push({
                        type: 'placement',
                        x,
                        y,
                        progress: 0,
                        duration: 40, // animation frames
                        tokenType: type,
                        player: gameState.currentPlayer
                    });
                });
                
                // Clear selected cells
                gameState.selectedCells = [];
            } catch (error) {
                console.error("Error placing tokens:", error);
            }
        }

        // Process core interactions (fusions and eliminations)
        function processCoreInteractions() {
            try {
                console.log("Processing core interactions");
                
                // Find all cells marked as just placed - these will be the sources for interactions
                const newCores = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const cell = gameState.grid[y][x];
                        if (cell.token && cell.justPlaced) {
                            // Calculate the value of this newly placed core
                            const value = cell.value || (cell.token.startsWith('charged') ? 2 : 1);
                            newCores.push({ x, y, value });
                            // Leave the justPlaced flag for now, will be used for fusion placement
                        }
                    }
                }
                
                console.log(`Found ${newCores.length} newly placed cores to check for interactions`);
                
                // First handle eliminations - any opponent core adjacent to newly placed cores
                const eliminations = [];
                const eliminatedPositions = new Set(); // Track positions to avoid duplicates
                
                newCores.forEach(core => {
                    // Get the value of this newly placed core
                    const placedCoreValue = core.value;
                    console.log(`Checking for eliminations from core at (${core.x}, ${core.y}) with value ${placedCoreValue}`);
                    
                    // Get adjacent cells
                    const adjacentCells = getAdjacentCells(core.x, core.y);
                    
                    // Check for opponent cores to eliminate (only equal or lesser value)
                    adjacentCells.forEach(adjInfo => {
                        const adjCell = adjInfo.cell;
                        if (!adjCell.token) return;
                        
                        const adjTokenParts = adjCell.token.split('-');
                        const adjPlayer = parseInt(adjTokenParts[1]);
                        const adjTokenType = adjTokenParts[0];
                        
                        // Calculate the value of the adjacent enemy core
                        const adjCoreValue = adjCell.value || (adjTokenType === 'energy' ? 1 : 2);
                        
                        // If adjacent core belongs to opponent AND has equal or lesser value
                        if (adjPlayer !== gameState.currentPlayer && adjCoreValue <= placedCoreValue) {
                            const posKey = `${adjInfo.x},${adjInfo.y}`;
                            
                            // Skip if already processed
                            if (eliminatedPositions.has(posKey)) return;
                            eliminatedPositions.add(posKey);
                            
                            console.log(`Found eligible elimination at (${adjInfo.x}, ${adjInfo.y}): value ${adjCoreValue} <= ${placedCoreValue}`);
                            
                            // Add to eliminations
                            eliminations.push({
                                x: adjInfo.x,
                                y: adjInfo.y,
                                token: adjCell.token,
                                tokenType: adjTokenParts[0],
                                player: adjPlayer,
                                eliminatedBy: gameState.currentPlayer,
                                value: adjCoreValue
                            });
                        } else if (adjPlayer !== gameState.currentPlayer) {
                            console.log(`Skipping elimination at (${adjInfo.x}, ${adjInfo.y}): value ${adjCoreValue} > ${placedCoreValue}`);
                        }
                    });
                });
                
                // Then handle fusions - for each newly placed core, find connected friendly cores
                const fusions = [];
                const processedForFusion = new Set(); // Track positions we've already processed
                
                newCores.forEach(newCore => {
                    const posKey = `${newCore.x},${newCore.y}`;
                    
                    // Skip if this core has already been included in a fusion
                    if (processedForFusion.has(posKey)) return;
                    
                    const cell = gameState.grid[newCore.y][newCore.x];
                    if (!cell.token) return; // Safety check
                    
                    const tokenParts = cell.token.split('-');
                    const player = parseInt(tokenParts[1]);
                    
                    // Check adjacent cells for same player cores
                    const adjacentCells = getAdjacentCells(newCore.x, newCore.y);
                    const sameCores = adjacentCells.filter(adjInfo => {
                        if (!adjInfo.cell.token) return false;
                        
                        const adjTokenParts = adjInfo.cell.token.split('-');
                        return parseInt(adjTokenParts[1]) === player;
                    });
                    
                    // If we found adjacent cores of the same player, create a fusion
                    if (sameCores.length > 0) {
                        // Start BFS from this newly placed core to find all connected cores
                        const fusionCells = [];
                        const queue = [newCore]; // Start with newly placed core
                        const visited = new Set([posKey]);
                        
                        while (queue.length > 0) {
                            const current = queue.shift();
                            fusionCells.push(current);
                            processedForFusion.add(`${current.x},${current.y}`);
                            
                            // Check all adjacent cells
                            const adj = getAdjacentCells(current.x, current.y);
                            adj.forEach(adjInfo => {
                                const adjCell = adjInfo.cell;
                                const adjKey = `${adjInfo.x},${adjInfo.y}`;
                                
                                // If adjacent cell has a token of the same player and not visited
                                if (adjCell.token && !visited.has(adjKey)) {
                                    const adjTokenParts = adjCell.token.split('-');
                                    const adjPlayer = parseInt(adjTokenParts[1]);
                                    
                                    if (adjPlayer === player) {
                                        queue.push({ x: adjInfo.x, y: adjInfo.y });
                                        visited.add(adjKey);
                                    }
                                }
                            });
                        }
                        
                        // If we found more than one cell (the newly placed one plus at least one existing)
                        if (fusionCells.length > 1) {
                            // Calculate total value
                            let totalValue = 0;
                            let hasChargedCore = false;
                            
                            fusionCells.forEach(cell => {
                                const cellData = gameState.grid[cell.y][cell.x];
                                const cellValue = cellData.value || 
                                          (cellData.token && cellData.token.startsWith('charged') ? 2 : 1);
                                totalValue += cellValue;
                                
                                // Check if any core is charged
                                if (cellData.token && cellData.token.startsWith('charged')) {
                                    hasChargedCore = true;
                                }
                            });
                            
                            fusions.push({
                                cells: fusionCells,
                                player: player,
                                newValue: totalValue,
                                resultType: hasChargedCore ? 'charged' : 'energy',
                                // Explicitly set the newly placed core as the target for fusion
                                targetCell: newCore
                            });
                        }
                    }
                });
                
                console.log(`Found ${fusions.length} fusions and ${eliminations.length} eliminations`);
                
                // Now clear the justPlaced flags as we're done with the identification phase
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        if (gameState.grid[y][x].justPlaced) {
                            gameState.grid[y][x].justPlaced = false;
                        }
                    }
                }
                
                // Process all interactions
                if (fusions.length > 0) {
                    // Animate fusions
                    fusions.forEach(fusion => {
                        animations.push({
                            type: 'fusion',
                            cells: fusion.cells,
                            progress: 0,
                            duration: 50,
                            player: fusion.player,
                            newValue: fusion.newValue,
                            resultType: fusion.resultType,
                            targetCell: fusion.targetCell
                        });
                    });
                    
                    // Apply fusions after animation
                    setTimeout(() => {
                        applyFusions(fusions);
                        
                        // Then process eliminations
                        if (eliminations.length > 0) {
                            setTimeout(() => {
                                processEliminations(eliminations);
                            }, 500);
                        } else {
                            setTimeout(() => {
                                finishTurn();
                            }, 300);
                        }
                    }, 600);
                } else if (eliminations.length > 0) {
                    // Process eliminations directly if no fusions
                    processEliminations(eliminations);
                } else {
                    // No interactions, end turn
                    finishTurn();
                }
            } catch (error) {
                console.error("Error processing core interactions:", error);
                gameState.turnPhase = 'selecting'; // Reset phase on error
                updateGameStatus("Error processing turn", true);
            }
        }

        // Check for core interactions
        function checkCoreInteractions() {
            try {
                console.log("Checking for core interactions");
                const fusions = [];
                const eliminations = [];
                const processedCells = new Set(); // Track cells we've processed to avoid duplicates
                
                // Helper function to add a cell to the processed set
                const markProcessed = (x, y) => processedCells.add(`${x},${y}`);
                const isProcessed = (x, y) => processedCells.has(`${x},${y}`);
                
                // First pass: Find all newly placed tokens
                const placedTokens = [];
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const cell = gameState.grid[y][x];
                        if (!cell.token) continue;
                        
                        // Consider this a "newly placed" token if it was part of the current turn
                        const tokenParts = cell.token.split('-');
                        const player = parseInt(tokenParts[1]);
                        
                        if (player === gameState.currentPlayer) {
                            placedTokens.push({ x, y, player });
                        }
                    }
                }
                
                console.log(`Found ${placedTokens.length} tokens from current player`);
                
                // Process fusion chains
                placedTokens.forEach(token => {
                    // Skip if this cell was already processed in a previous fusion
                    if (isProcessed(token.x, token.y)) return;
                    
                    // Start a new fusion chain from this token
                    const fusionChain = [];
                    const tokenQueue = [token];
                    
                    // BFS to find all connected tokens of the same player
                    while (tokenQueue.length > 0) {
                        const current = tokenQueue.shift();
                        
                        // Skip if already processed
                        if (isProcessed(current.x, current.y)) continue;
                        
                        // Add to fusion chain and mark as processed
                        fusionChain.push(current);
                        markProcessed(current.x, current.y);
                        
                        // Get adjacent cells with tokens from the same player
                        const adjacentCells = getAdjacentCells(current.x, current.y);
                        
                        adjacentCells.forEach(adjInfo => {
                            const adjCell = adjInfo.cell;
                            if (!adjCell.token) return;
                            
                            const adjTokenParts = adjCell.token.split('-');
                            const adjPlayer = parseInt(adjTokenParts[1]);
                            
                            // If same player and not processed, add to queue
                            if (adjPlayer === current.player && !isProcessed(adjInfo.x, adjInfo.y)) {
                                tokenQueue.push({ 
                                    x: adjInfo.x, 
                                    y: adjInfo.y, 
                                    player: adjPlayer 
                                });
                            }
                        });
                    });
                    
                    // If we found more than 1 token in the chain, it's a fusion
                    if (fusionChain.length > 1) {
                        console.log(`Found fusion chain with ${fusionChain.length} tokens`);
                        
                        // Calculate total value of fusion
                        let totalValue = 0;
                        fusionChain.forEach(cell => {
                            const cellValue = gameState.grid[cell.y][cell.x].value || 
                                              (gameState.grid[cell.y][cell.x].token.startsWith('charged') ? 2 : 1);
                            totalValue += cellValue;
                        });
                        
                        fusions.push({
                            cells: fusionChain.map(cell => ({ x: cell.x, y: cell.y })),
                            player: token.player,
                            newValue: totalValue
                        });
                    }
                });
                
                // Reset processed cells tracker for eliminations
                processedCells.clear();
                
                // Check for eliminations by checking all opponent tokens adjacent to current player tokens
                placedTokens.forEach(token => {
                    const adjacentCells = getAdjacentCells(token.x, token.y);
                    
                    adjacentCells.forEach(adjInfo => {
                        const adjCell = adjInfo.cell;
                        if (!adjCell.token) return;
                        
                        const adjTokenParts = adjCell.token.split('-');
                        const adjPlayer = parseInt(adjTokenParts[1]);
                        
                        // If opponent token and not already processed
                        if (adjPlayer !== token.player && !isProcessed(adjInfo.x, adjInfo.y)) {
                            markProcessed(adjInfo.x, adjInfo.y);
                            
                            // Add to eliminations
                            eliminations.push({
                                x: adjInfo.x,
                                y: adjInfo.y,
                                token: adjCell.token,
                                tokenType: adjTokenParts[0],
                                player: adjPlayer,
                                eliminatedBy: token.player,
                                value: adjCell.value || (adjTokenParts[0] === 'energy' ? 1 : 2)
                            });
                        }
                    });
                });
                
                console.log(`Found ${fusions.length} fusions and ${eliminations.length} eliminations`);
                return { fusions, eliminations };
            } catch (error) {
                console.error("Error checking core interactions:", error);
                return { fusions: [], eliminations: [] };
            }
        }

        // Apply fusion results
        function applyFusions(fusions) {
            try {
                if (fusions.length === 0) {
                    console.log("No fusions to apply");
                    return;
                }
                
                fusions.forEach(fusion => {
                    console.log(`Applying fusion: ${fusion.cells.length} cells with new value ${fusion.newValue}`);
                    
                    // Use the explicitly specified target cell for the fusion result
                    // This should be the newly placed core that triggered the fusion
                    const targetCell = fusion.targetCell;
                    console.log(`Using target cell for fusion at (${targetCell.x}, ${targetCell.y})`);
                    
                    // Count how many charged cores are being consumed in this fusion
                    let chargedCoresConsumed = 0;
                    for (const cell of fusion.cells) {
                        const cellData = gameState.grid[cell.y][cell.x];
                        if (cellData.token && cellData.token.startsWith('charged')) {
                            chargedCoresConsumed++;
                        }
                    }
                    
                    // Update the target cell's token type and value
                    gameState.grid[targetCell.y][targetCell.x].token = `${fusion.resultType || 'energy'}-${fusion.player}`;
                    gameState.grid[targetCell.y][targetCell.x].value = fusion.newValue;
                    gameState.grid[targetCell.y][targetCell.x].glow = 1;
                    
                    console.log(`Fusion result at (${targetCell.x}, ${targetCell.y}): ${fusion.resultType || 'energy'} token with value ${fusion.newValue}`);
                    
                    // Remove other cells involved in the fusion
                    for (const cell of fusion.cells) {
                        if (cell.x !== targetCell.x || cell.y !== targetCell.y) {
                            console.log(`Removing fused token at (${cell.x}, ${cell.y})`);
                            gameState.grid[cell.y][cell.x].token = null;
                            gameState.grid[cell.y][cell.x].value = null;
                        }
                    }

                    // If the fusion resulted in a charged core, increment the player's charged core count
                    if (fusion.resultType === 'charged') {
                        gameState.players[fusion.player].chargedTokens++;
                        console.log(`Player ${fusion.player + 1} gained a charged core from fusion`);
                        console.log(`Player ${fusion.player + 1} now has ${gameState.players[fusion.player].chargedTokens} charged cores`);
                    }
                    
                    // Adjust charged core count based on consumed cores
                    if (chargedCoresConsumed > 0) {
                        gameState.players[fusion.player].chargedTokens -= (chargedCoresConsumed - 1); // -1 because one becomes the new core
                        console.log(`Player ${fusion.player + 1} consumed ${chargedCoresConsumed} charged cores in fusion`);
                        console.log(`Player ${fusion.player + 1} now has ${gameState.players[fusion.player].chargedTokens} charged cores`);
                    }
                });
                
                // Update player cards
                updatePlayerCards();
                console.log("Fusions applied successfully");
            } catch (error) {
                console.error("Error applying fusions:", error);
            }
        }

        // Process eliminations
        function processEliminations(eliminations) {
            try {
                if (!eliminations || eliminations.length === 0) {
                    // No eliminations, finish turn
                    console.log("No eliminations to process");
                    finishTurn();
                    return;
                }
                
                console.log(`Processing ${eliminations.length} eliminations`);
                
                // Track which cores have been eliminated to avoid duplicates in chain reactions
                const eliminatedPositions = new Set();
                
                // Track total eliminated value and eliminations by player
                let totalEliminatedValue = 0;
                const eliminationsByPlayer = {};
                
                // Process eliminations and check for chain reactions
                const processEliminationChain = function(currentEliminations) {
                    if (!currentEliminations || currentEliminations.length === 0) {
                        return;
                    }
                    
                    const nextRoundEliminations = [];
                    
                    currentEliminations.forEach(elim => {
                        const posKey = `${elim.x},${elim.y}`;
                        if (eliminatedPositions.has(posKey)) {
                            return;
                        }
                        
                        // Get the value of the eliminated core
                        const value = elim.value || (elim.tokenType === 'energy' ? 1 : 2);
                        totalEliminatedValue += value;
                        
                        // Track eliminations by player
                        if (!eliminationsByPlayer[elim.player]) {
                            eliminationsByPlayer[elim.player] = 0;
                        }
                        eliminationsByPlayer[elim.player]++;
                        
                        // Mark this position as eliminated
                        eliminatedPositions.add(posKey);
                        
                        // Remove token from the grid
                        gameState.grid[elim.y][elim.x].token = null;
                        gameState.grid[elim.y][elim.x].value = null;
                        
                        // Add elimination animation
                        animations.push({
                            type: 'elimination',
                            target: { x: elim.x, y: elim.y },
                            token: elim.token,
                            attacker: elim.eliminatedBy,
                            defender: elim.player,
                            progress: 0,
                            duration: 40,
                            value: value
                        });
                        
                        // Check for chain reactions
                        const adjacentCells = getAdjacentCells(elim.x, elim.y);
                        adjacentCells.forEach(adjInfo => {
                            if (!adjInfo.cell || !adjInfo.cell.token) return;
                            
                            const adjTokenParts = adjInfo.cell.token.split('-');
                            const adjPlayer = parseInt(adjTokenParts[1]);
                            const adjTokenType = adjTokenParts[0];
                            const adjValue = adjInfo.cell.value || (adjTokenType === 'energy' ? 1 : 2);
                            
                            // Check all cores adjacent to this one for potential attackers
                            const adjToAdjCells = getAdjacentCells(adjInfo.x, adjInfo.y);
                            adjToAdjCells.forEach(attackerInfo => {
                                if (!attackerInfo.cell || !attackerInfo.cell.token) return;
                                
                                const attackerTokenParts = attackerInfo.cell.token.split('-');
                                const attackerPlayer = parseInt(attackerTokenParts[1]);
                                const attackerValue = attackerInfo.cell.value || 
                                    (attackerTokenParts[0] === 'energy' ? 1 : 2);
                                
                                if (attackerPlayer !== adjPlayer && attackerValue > adjValue) {
                                    nextRoundEliminations.push({
                                        x: adjInfo.x,
                                        y: adjInfo.y,
                                        token: adjInfo.cell.token,
                                        value: adjValue,
                                        player: adjPlayer,
                                        eliminatedBy: attackerPlayer
                                    });
                                }
                            });
                        });
                    });
                    
                    if (nextRoundEliminations.length > 0) {
                        setTimeout(() => {
                            processEliminationChain(nextRoundEliminations);
                        }, 100);
                    }
                };
                
                // Start the chain reaction process
                processEliminationChain(eliminations);
                
                // Update game state
                gameState.players[gameState.currentPlayer].score += totalEliminatedValue;
                updatePlayerCards();
                
                // Check for game end
                if (gameState.players[gameState.currentPlayer].score >= WINNING_SCORE) {
                    console.log("Game over! Player reached winning score.");
                    gameState.gameOver = true;
                    updateGameStatus("Game over! You reached the winning score.");
                    setTimeout(() => {
                        finishTurn();
                    }, 300);
                } else {
                    console.log("Eliminations processed successfully");
                    updateGameStatus("Eliminations processed successfully");
                    setTimeout(() => {
                        finishTurn();
                    }, 300);
                }
            } catch (error) {
                console.error("Error processing eliminations:", error);
                gameState.turnPhase = 'selecting'; // Reset phase on error
                updateGameStatus("Error processing eliminations", true);
            }
        }

        // Finish the current turn
        function finishTurn() {
            console.log("Finishing turn");
            
            if (!gameReadyToRender) {
                console.log("Game not ready for turn end");
                updateGameStatus("Game still initializing...");
                return;
            }
            
            if (gameState.turnPhase !== 'selecting' || gameState.gameOver) {
                console.log("Cannot finish turn: incorrect phase or game over");
                updateGameStatus(gameState.gameOver ? "Game is over!" : "Cannot finish turn during animations");
                return;
            }
            
            // Reset turn phase
            gameState.turnPhase = 'selecting';
            console.log("Turn finished, resetting to selecting phase");
            updateGameStatus("Turn finished, resetting to selecting phase");
            
            // Update player cards
            updatePlayerCards();
            
            // Reset selection mode
            setSelectionMode('energy');
            
            // Reset selected cells
            gameState.selectedCells = [];
            
            // Reset energy token flag for next turn
            gameState.placedEnergyToken = false;
            
            // Reset game over flag
            gameState.gameOver = false;
            
            // Reset animations
            animations = [];
            particles = [];
            
            // Re-render the game
            render();
            
            console.log("Turn finished successfully");
            updateGameStatus("Turn finished successfully");
        }

        // Render the game
        function render() {
            try {
                console.log("Rendering game");
                
                // Clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Render particles
                particles.forEach(particle => {
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${PLAYER_COLORS[gameState.currentPlayer].join(',')},${particle.alpha})`;
                    ctx.fill();
                });
                
                // Render animations
                animations.forEach(animation => {
                    const { type, x, y, progress, duration, tokenType, player, newValue, resultType, targetCell } = animation;
                    
                    if (type === 'placement') {
                        ctx.beginPath();
                        ctx.arc(x * cellSize + cellSize / 2, y * cellSize + cellSize / 2, cellSize / 2, 0, Math.PI * 2);
                        ctx.fillStyle = PLAYER_COLORS[player];
                        ctx.fill();
                    } else if (type === 'fusion') {
                        // Fusion animation logic
                    } else if (type === 'elimination') {
                        // Elimination animation logic
                    }
                });
                
                // Render player cards
                createPlayerCards();
                
                console.log("Game rendered successfully");
            } catch (error) {
                console.error("Error rendering game:", error);
            }
        }

        // Get adjacent cells
        function getAdjacentCells(x, y) {
            const cells = [];
            const directions = [
                { dx: 0, dy: -1 }, { dx: 0, dy: 1 }, { dx: -1, dy: 0 }, { dx: 1, dy: 0 }
            ];
            
            directions.forEach(({ dx, dy }) => {
                const adjX = x + dx;
                const adjY = y + dy;
                if (adjX >= 0 && adjX < GRID_SIZE && adjY >= 0 && adjY < GRID_SIZE) {
                    cells.push({ x: adjX, y: adjY });
                }
            });
            
            return cells;
        }

        // Initialize game
        function init() {
            console.log("Initializing game");
            
            initGrid();
            createPlayerCards();
            resizeCanvas();
            
            gameReadyToRender = true;
            console.log("Game initialized successfully");
        }

        // Event listeners
        document.getElementById('endTurnBtn').addEventListener('click', endTurn);
        document.getElementById('helpBtn').addEventListener('click', () => {
            document.getElementById('helpModal').style.display = 'flex';
        });
        document.getElementById('closeModal').addEventListener('click', () => {
            document.getElementById('helpModal').style.display = 'none';
        });

        // Initialize game
        init();
    </script>
</body>
</html>
